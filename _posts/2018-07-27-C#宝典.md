---
layout: post
title:  "C#宝典"
categories: C#
date:   2018-07-27 13:15:48
description: 技术类面试、笔试题汇总
keywords: 面试, C#
---

# 技术类面试、笔试题汇总
 
> 注：标明*的问题属于选择性掌握的内容，能掌握更好，没掌握也没关系。
>
> 下面的参考解答只是帮助大家理解，不用背，面试题、笔试题千变万化，不要梦想着把题覆盖了，下面的题是供大家查漏补缺用的，真正的把这些题搞懂了，才能“以不变应万变”。回答问题的时候能联系做过项目的例子是最好的，有的问题后面我已经补充联系到项目中的对应的案例了。

## 1、简述 private、 protected、 public、 internal 修饰符的访问权限

> private : 私有成员, 在类的内部才可以访问。
>
> protected : 保护成员，该类内部和继承类中可以访问。
>
> public : 公共成员，完全公开，没有访问限制。
>
> internal: 当前程序集内可以访问。

## 2、ADO.NET中的五个主要对象

> **Connection**：主要是开启程序和数据库之间的连接。没有利用连接对象将数据库打开，是无法从数据库中取得数据的。Close和Dispose的区别，Close以后还可以Open，Dispose以后则不能再用。
>
> **Command**：主要可以用来对数据库发出一些指令，例如可以对数据库下达查询、新增、修改、删除数据等指令，以及调用存在数据库中的存储过程等。这个对象是架构在Connection 对象上，也就是Command 对象是透过连接到数据源。
>
> **DataAdapter**：主要是在数据源以及DataSet 之间执行数据传输的工作，它可以透过Command 对象下达命令后，并将取得的数据放入DataSet 对象中。这个对象是架构在Command对象上，并提供了许多配合DataSet 使用的功能。
>
> **DataSet**：这个对象可以视为一个暂存区（Cache），可以把从数据库中所查询到的数据保留起来，甚至可以将整个数据库显示出来，***DataSet是放在内存中的***。DataSet 的能力不只是可以储存多个Table 而已，还可以透过DataAdapter对象取得一些例如主键等的数据表结构，并可以记录数据表间的关联。DataSet 对象可以说是ADO.NET 中重量级的对象，这个对象架构在DataAdapter对象上，本身不具备和数据源沟通的能力；也就是说我们是将DataAdapter对象当做DataSet 对象以及数据源间传输数据的桥梁。***DataSet包含若干DataTable、DataTableTable包含若干DataRow***。
>
> **DataReader**：当我们只需要循序的读取数据而不需要其它操作时，可以使用DataReader 对象。DataReader对象只是一次一笔向下循序的读取数据源中的数据，这些***数据是存在数据库服务器中的，而不是一次性加载到程序的内存中的，只能（通过游标）读取当前行的数据***，而且这些数据是只读的，并不允许作其它的操作。因为DataReader 在读取数据的时候限制了每次只读取一笔，而且只能只读，所以使用起来不但节省资源而且效率很好。使用DataReader 对象除了效率较好之外，因为不用把数据全部传回，故可以降低网络的负载。
>
> **ADO.NET** 使用Connection 对象来连接数据库，使用Command 或DataAdapter对象来执行SQL语句，并将执行的结果返回给DataReader 或 DataAdapter ,然后再使用取得的DataReader 或DataAdapter 对象操作数据结果。

## 3、列举ASP.NET 页面之间传递值的几种方式。

> 1.使用QueryString, 如....?id=1; response. Redirect()....
>
> 2.使用Session变量 
>
> 3.使用Server.Transfer
>
> 4.Cookie传值

## 4、C#中的委托是什么？事件是不是一种委托？事件和委托的关系。

> 委托可以把一个方法作为参数代入另一个方法。
>
> ***委托可以理解为指向一个函数的指针***。
>
> 委托和事件没有可比性，因为***委托是类型，事件是对象***，下面说的是委托的对象（用委托方式实现的事件）和（标准的event方式实现）事件的区别。***事件的内部是用委托实现的***。因为对于事件来讲，外部只能“注册自己+=、注销自己-=”，外界不可以注销其他的注册者，外界不可以主动触发事件，因此如果用Delegate就没法进行上面的控制，因此诞生了事件这种语法。事件是用来阉割委托实例的，类比用一个自定义类阉割List。事件只能add、remove自己，不能赋值。事件只能+=、-=，不能= 。加分的补充回答：***事件内部就是一个private的委托和add、remove两个方法***
>
> **面试聊**：用Reflector查看.Net的类的内部实现，解决问题。

## 5、override与重载（overload）的区别 

> 重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要。重载（overload）是面向过程的概念。
> Override 是进行基类中函数的重写。Override是面向对象的概念
  
## 6、C#中索引器是否只能根据数字进行索引？是否允许多个索引器参数？

> 参数的个数和类型都是任意的。加分的补充回答：用reflector反编译可以看出，***索引器的内部本质上就是set_item、get_item方法***。
>
> 基础知识：

    索引的语法：
    public string this[string s]，通过get、set块来定义取值、赋值的逻辑
    索引可以有多个参数、参数类型任意
    索引可以重载。
    如果只有get没有set就是只读的索引。
    索引其实就是set_Item、get_Item两个方法。

## 7、属性和public字段的区别是什么？调用set方法为一个属性设值，然后用get方法读取出来的值一定是set进去的值吗？

> 属性可以对设值、取值的过程进行非法值控制，比如年龄禁止设值负数，而字段则不能进行这样的设置。虽然一般情况下get读取的值就是set设置的值，但是可以让get读取的值不是set设置的值的， ***极端的例子。Public Age{get{return 100;}set{}}*** 。加分的补充回答：用reflector反编译可以看出，属性内部本质上就是set_***、get_***方法，详细参考传智播客.net培训视频中串讲.net基础的部分。

```csharp
    class Person
    {
        public int Age
        {
            get
            {
                return 3;
            }
            set
            {

            }
        }
    }

        Person p1 = new Person();
        p1.Age = 30;
        p1.Age++;
        Console.Write(p1.Age);//输出3
```

## 8、三层架构

> 通常意义上的三层架构就是将整个业务应用划分为： ***表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）*** 。
>
> 区分层次的目的即为了“高内聚，低耦合”的思想。
>
> **表现层（UI）**：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候的所见所得。
>
> **业务逻辑层（BLL）**：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。
>
> **数据访问层（DAL）**：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等每层之间是一种垂直的关系。
>
> 三层结构是N层结构的一种，一般来说，层次之间是向下依赖的，下层代码未确定其接口（契约）前，上层代码是无法开发的，下层代码接口（契约）的变化将使上层的代码一起变化。
>
> **优点**： 分工明确，条理清晰，易于调试，而且具有可扩展性。
>
> **缺点**： 增加成本。

## 9、MVC模式 （*）

> MVC(Model View Controller)模型－视图－控制器
>
> aspx就是View，视图；Model：DataSet、Reader、对象；Controller：cs代码。
>
> MVC是典型的平行关系，没有说谁在上谁在下的关系，模型负责业务领域的事情，视图负责显示的事情，控制器把数据读取出来填充模型后把模型交给视图去处理。而各种验证什么的应该是在模型里处理了。它强制性的使应用程序的输入、处理和输出分开。MVC最大的好处是将逻辑和页面分离。
>
> MVC和三层的区别：MVC是UI层的技术。

## 10、关于拆箱装箱：

### 10.1、什么是装箱(boxing)和拆箱(unboxing)？ （*）

> Object是引用类型，但是它的子类Int32竟然不能去Object能去的“要求必须是引用类型” 的地方，违反了继承的原则，所以需要把Int32装在Object中才能传递。
>
> 装箱：从值类型接口转换到引用类型。
>
> 拆箱：从引用类型转换到值类型。

```csharp
object obj = null;//引用类型
obj = 1;//装箱，boxing。把值类型包装为引用类型。
int i1 = (int)obj;//拆箱。unboxing
```

### 10.2、下面三句代码有没有错，以inboxing或者unboxing为例，解释一下内存是怎么变化的

```csharp
int i=10;
object obj = i;
int j = obj;
```

> 分析：在inboxing（装箱）时是不需要显式的类型转换的，不过unboxing（拆箱）需要显式的类型转换，所以第三行代码应该改为：

```csharp
3 int j = (int)obj;
```

>要掌握装箱与拆箱，就必须了解CTS及它的特点：
>
>(Common Type System)。CTS是为了实现在应用程序声明和使用这些类型时必须遵循的规则而存在的通用类型系统。.Net将整个系统的类型分成两大类 ：值类型和引用类型。
>
> CTS中的所有东西都是对象；所有的对象都源自一个基类——System.Object类型。值类型的一个最大的特点是它们不能为null，值类型的变量总有一个值。为了解决值类型不可以为null，引用类型可以为null的问题，微软在.Net中引入了装箱和拆箱：***装箱就是将值类型用引用类型包装起来转换为引用类型；而从引用类型中拿到被包装的值类型数据进行拆箱***。

```csharp
object.ReferenceEquals();//用来判断两个对象是否是同一个对象
Console.WriteLine(object.ReferenceEquals(3,3));//因为两个3被装到了两个箱子中，所以是false
```

> Equals ==的关系

## 12、CTS、CLS、CLR分别作何解释（*）把英文全称背过来。

> C#和.Net的关系。
>
> C#只是抽象的语言，可以把C#编译生成Java平台的二进制代码，也可以把Java代码编译生成.Net平台的二进制代码。所以C#只是提供了if、while、+-*/、定义类、int、string等基础的语法，而Convert.ToInt32、FileStream、SqlConnection、String.Split等都属于.Net的东西。深蓝色是C#的，浅蓝色是.Net的。
> 
> C# new→IL:newobj
>
> C# string →.Net中的String
>
> 类型的差别：.net中的Int32在C#中是int，在VB.Net中是Integer。
>
> 语法的差别：IL中创建一个对象的方法是L_0001: newobj instance void 索引.C1::.ctor()
>
> C#中是new C1();VB.net中是 Dim c1 As New C1
>
> ***CTS：Common Type System*** 通用类型系统。Int32、Int16→int、String→string、Boolean→bool。每种语言都定义了自己的类型，.Net通过CTS提供了公共的类型，然后翻译生成对应的.Net类型。
>
> ***CLS：Common Language Specification*** 通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.Net通过CLS提供了公共的语法，然后不同语言翻译生成对应的.Net语法。
>
> ***CLR：Common Language Runtime*** 公共语言运行时，就是GC、JIT等这些。有不同的CLR，比如服务器CLR、Linux CLR（Mono）、Silverlight CLR(CoreCLR)。相当于一个发动机，负责执行IL。

## 13、在dotnet中类(class)与结构(struct)的异同？

Class可以被实例化,属于 ***引用类型*** ,是分配在内存的堆上的。类是引用传递的。
Struct属于值类型,是分配在内存的栈上的。结构体是复制传递的。加分的回答：Int32、Boolean等都属于结构体。

## 14、堆和栈的区别？

> 栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义；***局部值类型变量、值类型参数等都在栈内存中***。
> 
> 堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小。

## 15、能用foreach遍历访问的对象的要求

> 需要实现 ***IEnumerable*** 接口或声明GetEnumerator方法的类型。

## 16、GC是什么? 为什么要有GC?

> C/C++中由程序员进行对象的回收像学校食堂中由学生收盘子，.Net中由GC进行垃圾回收像餐馆中店员去回收。
> 
> GC是垃圾收集器（***Garbage Collection***）。程序员不用担心内存管理，因为垃圾收集器会自动进行管理。***GC只能处理托管内存资源的释放，对于非托管资源则不能使用GC进行回收，必须由程序员手工回收，一个例子就是FileStream或者SqlConnection需要程序员调用Dispose进行资源的回收***。
>
> 要请求垃圾收集，可以调用下面的方法：GC.Collect()一般不需要手动调用GC.Collect()。当一个对象没有任何变量指向（不再能使用）的时候就可以被回收了。
>
> **基础知识**：当没有任何变量指向一个对象的时候对象就 ***可以*** 被回收掉了，但不一定会立即被回收。

```csharp
object obj = new object();//只有new才会有新对象
Console.WriteLine(obj);

object obj2 = obj;
obj = null;
obj2 = null;
Console.WriteLine();
```

## 17、

```csharp
 string s1 = "abc";
string s2 = "123";
string s3 = "abc";
```

上面代码有两个字符串对象，因为s1、s3都引用了字符串拘留池中的"abc"

```csharp
string s1 = "abc";
string s2 = "123";
string s4 = new string(new char[]{'a','b','c'});
```

中有三个字符串对象，因为new就一定会创建新的字符串对象

> **基础知识**：字符串拘留池（Intern）
>
> 因为字符串是不可变的，所以如果程序发现声明了一个之前声明过的字符串，那么会复用之前的那个字符串对象的实例。

```csharp
string s1 = "abc";
string s2 = "123";
string s3 = "abc";

//string s4 = new string("abc");//错误的用法
string s4 = new string(new char[]{'a','b','c'});

Console.WriteLine(object.ReferenceEquals(s1,s2));
Console.WriteLine(object.ReferenceEquals(s1, s3));//字符串拘留池复用对象
Console.WriteLine(object.ReferenceEquals(s1, s4));//new就会创建新的对象
```

## 18、值类型和引用类型的区别？

> 1.将一个值类型变量赋给另一个值类型变量时，将复制包含的值。引用类型变量的赋值只复制对对象的引用，而不复制对象本身。
>
> 2.值类型不可能派生出新的类型：所有的值类型均隐式派生自 System.ValueType。但与引用类型相同的是，结构也可以实现接口。
>
> 3.值类型不可能包含 null 值：然而，可空类型功能允许将 null 赋给值类型。
>
> 4.每种值类型均有一个隐式的默认构造函数来初始化该类型的默认值。

## 19、C#中的接口和类有什么异同。

不同点：
> 不能直接实例化接口。
>
> 接口不包含方法的实现。
>
>接口可以多继承，类只能单继承。
>
> 类定义可在不同的源文件之间进行拆分。

相同点：
> 接口、类和结构都可以从多个接口继承。
>
> 接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。
>
> 接口和类都可以包含事件、索引器、方法和属性。

基础知识：
> 接口只能定义方法（只能定义行为，不能定义实现也就是字段），因为事件、索引器、属性本质上都是方法，所以接口中也可以定义事件、索引器、属性。

## 20、abstract class和interface有什么区别？

相同点:
> ***都不能被直接实例化***，都可以通过继承实现其抽象方法。

不同点:
> ***接口支持多继承；抽象类不能实现多继承***。
> 
> ***接口只能定义行为；抽象类既可以定义行为，还可能提供实现***。
>
> 接口只包含方法(Method)、属性(Property)、索引器(Index)、事件(Event)的签名，但不能定义字段和包含实现的方法；
>
> 抽象类可以定义字段、属性、包含有实现的方法。
>
> 接口可以作用于值类型(Struct)和引用类型(Class)；抽象类只能作用于引用类型。例如，Struct就可以继承接口，而不能继承类。

加分的补充回答：
>讲设计模式的时候SettingsProvider的例子。

## 21、是否可以继承String类？

> String类是sealed类故不可以继承。

## 22、

```csharp
static void Main(string[] args)
{
    Console.WriteLine(GetIt());
    Console.ReadKey();
}

static int GetIt()
{
    int i = 8;
    try
    {
        i++;
        Console.WriteLine("a");
        return i;//把返回值设定为i，然后“尽快”返回（没啥事就回去吧）
    }
    finally
    {
        Console.WriteLine("b");
        i++;
    }
}
```

> 上面程序的执行结果是ab9
>
> try {}里有一个return语句，那么紧跟在这个try后的finally {}里的代码会不会被执行，什么时候被执行? 
会执行，在return后执行。

```csharp
static void Main(string[] args)
{
    //Console.WriteLine(GetIt());
    Console.WriteLine(GetPerson().Age);
    Console.ReadKey();
}

static int GetIt()
{
    int i = 8;
    try
    {
        i++;
        Console.WriteLine("a");
        return i;//把返回值设定为i，然后“尽快”返回（没啥事就回去吧。搞完就走）
    }
    finally
    {
        Console.WriteLine("b");
        i++;
    }
}

static Person GetPerson()
{
    Person p = new Person();
    p.Age = 8;
    try
    {
        p.Age++;
        Console.WriteLine("a");
        return p;//把返回值设定为i，然后“尽快”返回（没啥事就回去吧。搞完就走）
    }
    finally
    {
        Console.WriteLine("b");
        p.Age++;
    }
}
```

加分的补充回答（也助记）：读取数据库中数据的条数的程序

```csharp
public int QueryCount()
{
   …..
   try
   {
      return cmd.ExecuteScalar();
   }
   finally
   {
      cmd.Dispose();
   }
}
```

> 先执行cmd.ExecuteScalar()，把返回值暂时存起来，然后再去执行finally（钱放在这，我去劫个色），然后把返回值返回。return都是最后执行，但是return后的表达式的计算则是在finally之前。
>
> 如果C#设计的是先执行cmd.Dispose()再执行return就会出现return执行失败了，因为cmd已经Dispose了。

## 23、new 关键字用法（*）

> new 运算符 用于创建对象和调用构造函数。
>
> ***new 修饰符 用于向基类成员隐藏继承成员。表示“我的这个方法和父类的同名方法没关系”，new只是不让编译器警告而已***
> 
> new 约束 用于在泛型声明中约束可能用作类型参数的参数的类型。


## 25、描述线程与进程的区别？（*）

> 1.线程(Thread)与进程（Process）二者都定义了某种边界，不同的是进程定义的是应用程序与应用程序之间的边界，不同的进程之间不能共享代码和数据空间，而线程定义的是代码执行堆栈和执行上下文的边界。
>
> 2.***一个进程可以包括若干个线程***，同时创建多个线程来完成某项任务，便是多线程。而同一进程中的不同线程共享代码和数据空间。用一个比喻来说，如果一个家庭代表一个进程，在家庭内部，各个成员就是线程，家庭中的每个成员都有义务对家庭的财富进行积累，同时也有权利对家庭财富进行消费，当面对一个任务的时候，家庭也可以派出几个成员来协同完成，而家庭之外的人则没有办法直接消费不属于自己家庭的财产。

## 27、什么是反射？

> 程序集包含模块，而模块又包括类型，类型下有成员，反射就是管理程序集，模块，类型的对象，它能够动态的创建类型的实例，设置现有对象的类型或者获取现有对象的类型，能调用类型的方法和访问类型的字段属性。它是在运行时创建和使用类型实例 

加分的补充回答：***聊用反射实现编辑器动态插件和如鹏网项目中插件体系实现第三方支付和定时任务的案例***。

## 28、int、DateTime、string是否可以为null?

> null表示“不知道”，而不是“没有”。没有年龄和不知道年龄是不一样。
>
> 数据库中null不能用0表示。0岁和不知道多少岁不一样。
>
> Sex is zero。《色即是空》

```csharp
//int i1 = null;
//int? i2 = null;//值类型后加?就成了可空数据类型
////int i3 = i2;//所以把可空的赋值给一定不能为空的会报错。
//int i4 = (int)i2;//可以显式转换，由程序员来保证“一定不为空”
//int? i5 = i4;//一定会成功！

//using()→try{]catch{}finally{}


//int?是微软的一个语法糖。是一种和int没有直接关系的Nullable类型

Nullable<int> d1 = new Nullable<int>();//int? d1=null;
Nullable<int> d2 = new Nullable<int>(3);//int? d2=3;
Console.WriteLine(d1==null);
```

> int、DateTime不能，因为其为Struct类型，而结构属于值类型，值类型不能为null,只有引用类型才能被赋值null。string可以为null。
>
> C#中int等值类型不可以为null、而数据库中的int可以为null，这就是纠结的地方。int?就变成了可空的int类型。bool?、DateTime?

```csharp
int i1 = 3;
int? i2 = i1;
//int i3 = i2;//不能把可能为空的赋值给一定不能为空的变量
int i3 = (int)i2;//显式转换
```

> 可空数据类型经典应用场景：三层中的Model属性的设计。
>
> int?翻译生成.Net的Nullable<int>，CTS。

## 29、using关键字有什么用？什么是IDisposable？

> using可以声明namespace的引入，还可以实现非托管资源的释放，***实现了IDisposiable的类在using中创建，using结束后会自动调用该对象的Dispose方法***，释放资源。

加分的补充回答：
> using其实等价于try……finally，用起来更方便。

## 30、XML 与 HTML 的主要区别

> 1、 XML是区分大小写字母的，HTML不区分。 
>
> 2、 ***在HTML中，如果上下文清楚地显示出段落或者列表键在何处结尾，那么你可以省略</p>或者</li>之类的结束 标记。在XML中，绝对不能省略掉结束标记***。

```html
HTML：<img src="1.jpg"><br><br>
XML：<img src="1.jpg"></img><br/><br/>
```

> 3、 在XML中，拥有单个标记而没有匹配的结束标记的元素必须用一个 / 字符作为结尾。这样分析器就知道不用 查找结束标记了。
>
> 4、 在XML中，属性值必须分装在引号中。在HTML中，引号是可用可不用的。 
>
> 5、 在HTML中，可以拥有不带值的属性名。在XML中，所有的属性都必须带有相应的值。
>
> XML是用来存储和传输数据的
>
> HTML是用来显示数据的
>
> 如果使用了完全符合XML语法要求的HTML，那么就叫做符合XHTML标准。符合XHTML标准的页面有利于SEO。

## 31、string str = null 与 string str = “”说明其中的区别。

> 答：string str = null 是不给他分配内存空间,而string str = \"\" 给它分配长度为空字符串的内存空间。 string str = null没有string对象，**string str = “”有一个字符串对象**。

```csharp
string s3 = string.Empty;//反编译发现，string.Empty就是在类构造函数中 Empty = "";
```

## 32.写出一条Sql语句：取出表A中第31到第40记录（SQLServer,以自动增长的ID作为主键,注意：ID可能不是连续的。

答：

解1:

```sql
select top 10 * from A where id not in (select top 30 id from A) 
```

演变步骤：

```sql
1）select top 30 id from T_FilterWords--取前条

2）select * from T_FilterWords where id not in (select top 30 id from T_FilterWords)--取id不等于前三十条的
--也就是把前条排除在外

3）select top 10 * from T_FilterWords where id not in (select top 30 id from T_FilterWords)
--取把前条排除在外的前条，也就是-40条
```

解2:

```sql
select top 10 * from A where id > (select max(id) from (select top 30 id from A )as A)
```

解答3：***用ROW_NUMBER实现***

## 33.面向对象的语言具有________性、_________性、________性

> 答：封装、继承、多态。

不要背，脑子中要有联想。

## 34.在.Net中所有可序列化的类都被标记为_____?

> 答：[serializable]

## 35、什么是code-Behind技术。

> 就是代码隐藏，在ASP.NET中通过ASPX页面指向CS文件的方法实现显示逻辑和处理逻辑的分离，这样有助于web应用程序的创建。比如分工，美工和编程的可以个干各的，不用再像以前asp那样都代码和html代码混在一起，难以维护。***code-Behind是基于部分类技术实现的，在我的项目的三层代码生成器中用到了部分类***。

## 36、接口是一种引用类型，在接口中可以声明（   ***a***），但不可以声明公有的域或私有的成员变量。

> a) 方法、属性、索引器和事件；
>
> b) 索引器和字段；
>
> c) 事件和字段；

解读：
> 接口中不能声明字段只能声明方法，属性、索引器和事件 最终都编译生成方法。因为字段属于实现层面的东西，只有存取值的时候才会用到字段，所以中接口中不能定义字段。

## 37. 在ADO.NET中，对于Command对象的ExecuteNonQuery()方法和ExecuteReader()方法，下面叙述错误的是（***c***）。

> a) insert、update、delete等操作的Sql语句主要用ExecuteNonQuery()方法来执行；
>
> b) ExecuteNonQuery()方法返回执行Sql语句所影响的行数。
>
> c) Select操作的Sql语句只能由ExecuteReader()方法来执行；
>
> d) ExecuteReader()方法返回一个DataReader对象；

拿SQLHelper实现一下。

## 38. 下列关于C#中索引器理解正确的是(***c***)

> a) 索引器的参数必须是两个或两个以上
>
> b) 索引器的参数类型必须是整数型
>
> c) 索引器没有名字
>
> d) 以上皆非

## 39. 下面关于XML的描述错误的是（***d***）。

> a) XML提供一种描述结构化数据的方法；
>
> b) XML   是一种简单、与平台无关并被广泛采用的标准；
>
> c) XML文档可承载各种信息；
>
> d) XML只是为了生成结构化文档；

## 40、以下的C#代码，试图用来定义一个接口：

```csharp
public   interface   IFile
{
          int   A;
          int   delFile()
          {
                  A   =   3;
          }
          void   disFile();
}
```

  关于以上的代码，以下描述错误的是(***d***)。
> a) 以上的代码中存在的错误包括：不能在接口中定义变量，所以int   A代码行将出现错误；
>
> b) 以上的代码中存在的错误包括：接口方法delFile是不允许实现的，所以不能编写具体的实现函数；
>
> c) 代码void   disFile();声明无错误，接口可以没有返回值；
>
> d) 代码void   disFile();应该编写为void   disFile(){}；

## 41、在ASP.NET中有Button控件myButton，要是单击控件时，导航到其他页面http://www.abc.com,   正确的代码为(***c***)。

> a)

``` csharp
private void myButton_Click(object sender, System.EventArgs e)
{
    Redirect(“http://www.abc.com”);
}
```

> b)

```csharp
private void myButton_Click(object sender, System.EventArgs   e)
{
    Request.Redirect(“http://www.abc.com”);
}
```

> c)

```csharp
private void myButton_Click(object sender, System.EventArgs   e)
{
    Reponse.Redirect(“http://www.abc.com”);
}
```

> d)

```csharp
private void myButton_Click(object sender, System.EventArgs   e)
{
    Request.Redirect(“http://www.abc.com”);
    return true;
}
```

## 42. 声明一个委托public   delegate   int   myCallBack(int   x);   则用该委托产生的回调方法的原型应该是（***b***）。

> a) void   myCallBack(int   x)   ；
>
> b) int   receive(int   num)   ；
>
> c) string   receive(int   x)   ；
>
> d) 不确定的；

## 43.StringBuilder 和 String 的区别？

> 答：***String 在进行运算时（如赋值、拼接等）会产生一个新的实例，而 StringBuilder 则不会。所以在大量字符串拼接或频繁对某一字符串进行操作时最好使用 StringBuilder***，不要使用 String
>
> 如果要操作一个不断增长的字符串，尽量不用String类,改用StringBuilder类。两个类的工作原理不同:String类是一种传统的修改字符串的方式，它确实可以完成把一个字符串添加到另一个字符串上的工作没错,但是在.NET框架下，这个操作实在是划不来。因为系统先是把两个字符串写入内存，接着删除原来的String对象，然后创建一个String对象，并读取内存中的数据赋给该对象。这一来二去的，耗了不少时间。而使用System.Text命名空间下面的StringBuilder类就不是这样了，它提供的Append方法，能够在已有对象的原地进行字符串的修改，简单而且直接。当然，一般情况下觉察不到这二者效率的差异，但如果你要对某个字符串进行大量的添加操作，那么StringBuilder类所耗费的时间和String类简直不是一个数量级的。

## 44、.请叙述属性与索引器的区别。 （*）

属性 | 索引器
---|---
通过名称标识 | 通过签名标识。
通过简单名称或成员访问来访问。 |  通过元素访问来访问。
可以为静态成员或实例成员。 |  必须为实例成员。
属性的   get   访问器没有参数。 |  索引器的   get   访问器具有与索引器相同的形参表。
属性的   set   访问器包含隐式   value   参数。 |  除了   value   参数外，索引器的   set   访问器还具有与索引器相同的形参表。

## 45.请叙述const与readonly的区别。（*）

> 对于公用的static字段，比如数据库连接字符串 ，如果有人有意无意的修改了它的值，系统就坏掉了，所以应该是设置成只读的：

```csharp
public static readonly string connstr =
            ConfigurationManager.ConnectionStrings["connstr"].ConnectionString;
```

> readonly的字段只能在声明时初始化，以后就不能再赋值了。

```csharp
public const string myconnstr="aaaaaaaaaaaaa";//定义常量，不变的量
```

> 永远不会变的量（今天、一万年以后，我这个电脑或者美国的电脑）都不会变的值才会声明为常量，比如圆周率可以，但是汇率不可以。通过计算出来的值就不能定义为常量，所以下面是错误的：

```csharp
public const string connstr =
            ConfigurationManager.ConnectionStrings["connstr"].ConnectionString;
```

> const 关键字用于修改字段或局部变量的声明。它指定字段或局部变量的值不能被修改。常数声明引入给定类型的一个或多个常数。
>
> const数据成员的声明式必须包含初值，且初值必须是一个常量表达式。因为它是在编译时就需要完全评估。
>
> const成员可以使用另一个const成员来初始化，前提是两者之间没有循环依赖。
>
> readonly在运行期评估赋值，使我们得以在确保“只读访问”的前提下，把object的初始化动作推迟到运行期进行。
>
> readonly 关键字与 const 关键字不同:
>
> const 字段只能在该字段的声明中初始化。
>
> readonly 字段可以在声明或构造函数中初始化。因此，根据所使用的构造函数，readonly 字段可能具有不同的值。另外，const 字段是编译时常数，而 readonly 字段可用于运行时常数。 ***const不能是“算出来的”***
>
> readonly 只能在声明时或者构造函数里面初始化，并且不能在 static 修饰的构造函数里面。

参考资料：

```url
http://www.cnblogs.com/royenhome/archive/2010/05/22/1741592.html
http://www.cnblogs.com/jams742003/archive/2010/03/23/1692913.html
http://www.cnblogs.com/wayfarer/archive/2006/04/27/386658.html
```

## 46．  请解释ASP。NET中的web页面与其隐藏类之间的关系？

> 一个ASP.NET页面一般都对应一个隐藏类,一般都在ASP.NET页面的声明中指定了隐藏类例如一个页面Tst1.aspx的页面声明如下

```html
<%@ Page language="c#" Codebehind="Tst1.aspx.cs" AutoEventWireup="false" Inherits="T1.Tst1" %>
```

> Codebehind="Tst1.aspx.cs" 表明经编译此页面时使用哪一个代码文件
>
> Inherits="T1.Tst1" 表用运行时使用哪一个隐藏类
>
> aspx页面会编译生成一个类，这个类从隐藏类继承。

## 47．  什么是viewstate，能否禁用？是否所用控件都可以禁用?

> Viewstate是保存状态的一种机制，EnableViewState属性设置为false即可禁用。

最有力的举例子：
> Label、TextBox在禁用ViewState后不同的表现来说明。

## 48、你对web service的体会？

> 答：如果自己写的一些程序也希望别人可以通过Web服务来使用，也可以把自己编写的方法贴上标签[WebMethed]来实现Web 服务。[是当编写程序时，希望实现一些别的网站已经实现过的，也用Web服务可视成XML语言的编码。可以使用别人的编码生成的XML找到自己需要的信息，来实现自己编写的程序的一些功能。把传智播客.net培训的如鹏网项目中用WebService实现管理客户端的例子说出来。
>
> SOAP、WSDL。
>
> WSDL：WebService Definition Language。就是描述WebService提供了那些方法的协议。
>
> SOAP：描述客户端向服务器端发送请求报文的格式（Http报文体的格式），服务器端返回的报文格式也是SOAP协议的。

## 49、您在什么情况下会用到虚方法？它与接口有什么不同？

> 答案：子类重新定义父类的某一个方法时，必须把父类的方法定义为virtual 
>
> 在定义接口中不能有方法体，虚方法可以。
>
> 实现时,子类可以不重新定义虚方法，但如果一个类继承接口，那必须实现这个接口。

## 50. 不定项选择：

(1) 以下叙述正确的是： ***B C***
> A. 接口中可以有虚方法。
>
> B. 一个类可以实现多个接口。
>
> C. 接口不能被实例化。
>
> D. 接口中可以包含已实现的方法。

(2) 从数据库读取记录，你可能用到的方法有：***B C D***
> A. ExecuteNonQuery
>
> B. ExecuteScalar
>
> C. Fill
>
> D. ExecuteReader

(3).对于一个实现了IDisposable接口的类，以下哪些项可以执行与释放或重置非托管资源相关的应用程序定义的任务？(多选)   (***ABCD***)
> A.Close
>
> B.Dispose
>
> C.Finalize
>
> D.using E.Quit

(4)以下关于ref和out的描述哪些项是正确的？(多选)   (***ACD***)
> A.使用ref参数，传递到ref参数的参数必须最先初始化。
>
> B.使用out参数，传递到out参数的参数必须最先初始化。
>
> C.使用ref参数，必须将参数作为ref参数显式传递到方法。
>
> D.使用out参数，必须将参数作为out参数显式传递到方法。

## 51. 单项选择：

（1）下列选项中，（***C***）是引用类型。
> a)enum类型
>
> b)struct类型
>
> c)string类型
>
> d)int类型

（2）.关于ASP.NET中的代码隐藏文件的描述正确的是（***C***）
> a)Web窗体页的程序的逻辑由代码组成，这些代码的创建用于与窗体交互。编程逻辑唯一与用户界面不同的文件中。该文件称作为“代码隐藏”文件，如果用C＃创建，该文件将具有“.ascx.cs”扩展名。
>
> b)项目中所有Web窗体页的代码隐藏文件都被编译成.EXE文件。
>
> c)项目中所有的Web窗体页的代码隐藏文件都被编译成项目动态链接库（.dll）文件。
>
> d)以上都不正确。

（3）.下列描述错误的是（***D***）
> a)类不可以多重继承而接口可以；
>
> b)抽象类自身可以定义成员而接口不可以；
>
> c)抽象类和接口都不能被实例化；
>
> d)一个类可以有多个基类和多个基接口；

## 52、DataReader和DataSet的异同？

> DataReader使用时始终占用SqlConnection,在线操作数据库
>
> 每次只在内存中加载一条数据,所以占用的内存是很小的
>
> 是只进的、 只读的
>
> DataSet则是将数据一次性加载在内存中.抛弃数据库连接..读取完毕即放弃数据库连接(非连接模式)
>
> DataSet将数据全部加载在内存中.所以比较消耗内存...但是确比DataReader要灵活..可以动态的添加行,列,数据.对数据库进行 回传更新操作(动态操作读入到内存的数据)

## 53、public static const; int  A = 1;这段代码有错误么？

> 错误：const不能被修饰为static ；因为定义为常量 （const ）后就是静态的（static ）。

## 54、传入某个属性的set方法的隐含参数的名称是什么？

> value，它的类型和属性所声名的类型相同。

## 55、C#支持多重继承么？

> 类之间不支持，接口之间支持。类对接口叫做实现，不叫继承。 类是爹、接口是能力，能有多个能力，但不能有多个爹。

## 56、C#中所有对象共同的基类是什么？

> System.Object

## 57、通过超链接怎样传递中文参数？

> 答：用URL编码，通过QueryString传递，用urlencode编码 用urldecode解码

## 58、string、String；int、Int32；Boolean、bool的区别

> String、Int32、Boolean等都属于.Net中定义的类，而string、int、bool相当于C#中对这些类定义的别名。CTS。

## 59、Server.Transfer和Response.Redirect的区别是什么？（常考）

> 答: ***Server.Transfer仅是服务器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；Response.Redirect则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址***。
>
> Server.Transfer是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 这个过程中浏览器和Web服务器之间经过了一次交互。
>
> Response.Redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求。这个过程中浏览器和Web服务器之间经过了两次交互。

## 60、不是说字符串是不可变的吗？string s="abc";s="123"不就是变了吗？

> String是不可变的在这段代码中，s原先指向一个String对象，内容是 "abc"，然后我们将s指向"123"，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为"123"，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。

## 61、是否可以从一个static方法内部发出对非static方法的调用？

> 不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不能发出对非static方法的调用。

## 63、说出一些常用的类、接口，请各举5个

> 要让人家感觉你对.Net开发很熟，所以，不能仅仅只列谁都能想到的那些东西，要多列你在做项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。
>
> 常用的类：StreamReader、WebClient、Dictionary<K, V>、StringBuilder、SqlConnection、FileStream、File、Regex、List<T> 
>
> 常用的接口：IDisposable、IEnumerable、IDbConnection、IComparable、ICollection、IList、IDictionary
>
> 要出乎意料！不要仅仅完成任务！笔试不是高考！处处要显出牛！

## 65、编写一个单例（Singleton）类。

参考复习ppt。

把构造函数设置为private，设置一个public、static的对象实例

```csharp
public FileManager
{
    private FileManager(){}
    public readonly static FileManager Instance = new FileManager();
}
```

扩展：搜“C#  Singleton”，有线程安全的更牛B的实现

## 66、什么是sql注入？如何避免sql注入？

> 用户根据系统的程序构造非法的参数从而导致程序执行不是程序员期望的恶意SQL语句。使用参数化的SQL就可以避免SQL注入。
>
> 详细参考复习ppt。举例子，摆事实！
>
> 1' or 1=1

## 67、数据库三范式是什么?

用自己的话解释，而不是背概念。
传智播客风格的非严谨却一下子明了的解答方式：
> 第一范式：字段不能有冗余信息，所有字段都是必不可少的。
>
> 第二范式：满足第一范式并且表必须有主键。
>
> 第三范式：满足第二范式并且表引用其他的表必须通过主键引用。

记忆顺序：自己内部不重复→别人引用自己→自己引用别人。

> 不一定满足第一范式，比如拼音检索中增加一个“拼音”字段。

Id | Name | Pinyin
---|---|---
1 | 杨中科 | yangzhongke
2 | 杨开慧 | yangkaihui
3 | 周妹妹 | zhaomeimei

```sql
where pinyin like 'yang%'
```

## 68、说出一些数据库优化方面的经验?如何优化有百万条数据的数据库？

> （1）***在经常检索的字段上（select * from Person where Name=@Name）使用索引提高查询速度。索引内部原理：想象成Dictionary，插入、删除、更新的速度慢了，加上索引也多占用了空间，查询的速度快了***，加上索引以后速度提升非常明显。对于范围查询的字段使用聚集索引。
>
>（2）select中只列出必要的字段，而不是*。
>
>（3）避免全表扫描：***避免隐式类型转换造成的全表扫描，在索引上使用函数也会造成全表扫描（因为索引只是为字段建立的，一旦使用表达式或者函数，那么索引就是失效了，当然也可以使用“函数索引”、“表达式索引”解决这个问题），使用索引不一定能提高查询速度。比如对于Name字段使用SubStr进行过滤就会造成全表扫描；避免字段计算造成的全表扫描。避免使用Like***。
>
>（4）避免在索引列上使用计算（where Name+'A'=@MyName）
加分的回答：不进行无意义优化，根据性能查看器的报表，对最耗时的SQL进行优化。

```sql
where Age+5=20 转变为 where age=15 
where DateDiff(day,getdate(),createdatetime)<=7 转变为
where createdatetime>=DateAdd(day,GetDate(),-7)
```

## 70、谈谈你对设计模式的理解（传智播客.Net培训班原创模拟题）

> 世界上本没有模式，用的人多了，也就有了模式。不用刻意记每种模式的名字，手中无模式，心中有模式。
>
> 大部分设计模式就是接口、抽象类的一个组合。ADO.Net基于接口编程，SafeDbCommand、SafeConnection。SettingsProvider。没必要记模式的名字。
>
> 举例：传智播客.net培训时SettingsProvider的例子、工厂模式的例子。

## 71、谈谈ViewState。谈谈对ASP.Net原理的理解。

> Label、Textbox在禁用ViewState的时候自增的不同表现
>
> ***Http是无状态的***，WebForm为了实现基于http的“有状态”从而简化开发，ViewState用来在两次请求间保持状态。页面返回前将界面的状态序列化到ViewState中，这样就将状态保存在了浏览器中，下次页面提交的时候会顺便再将ViewState提交到服务器，这样服务器就根据ViewState还原了状态，这样WebForm开发就像有状态一样了。谈谈自定义AutoInc控件。

常考：
> 谈谈ASP.Net生命周期。背邹老师讲课说的那串。并且说：这是WebForm控件开发才会涉及到生命周期（用户请求到IIS到ASP.Net这部分正常回答，可以蔑视的部分是页面那些PreRender等那些方法），我很少用服务端控件开发，在我眼中只有：请求处理响应！

## 72、post、get的区别

> get的参数会显示在浏览器地址栏中，而post的参数不会显示在浏览器地址栏中；
使用post提交的页面在点击【刷新】按钮的时候浏览器一般会提示“是否重新提交”，而get则不会；
>
> 用get的页面可以被搜索引擎抓取，而用post的则不可以；
>
> 用post可以提交的数据量非常大，而用get可以提交的数据量则非常小(2k)，受限于网页地址的长度。
>
> 用post可以进行文件的提交，而用get则不可以。

参考阅读：

```url
http://www.cnblogs.com/skynet/archive/2010/05/18/1738301.html 
```

## 73、下面的程序执行结果是什么？（传智播客.Net培训班原创模拟题）

```csharp
class Person
{
    public int Age { get; set; }
}

int i1 = 20;
int i2 = i1;
i1++;
Console.WriteLine(i2);

Person p1 = new Person();
p1.Age = 20;
Person p2 = p1;
p1.Age++;
Console.WriteLine(p2.Age);
```

答案：
> 20
>
> 21

解释：
> 引用类型和值类型的区别。

## 74、Http默认的端口号是（***80***）、Ftp默认的端口号是（***21***）、SQLServer的默认端口号是（***1433***）（传智播客.Net培训班原创模拟题）

## 76、下面程序的执行结果是什么？（传智播客.Net培训班原创模拟题）

```csharp
int i = 10;
Console.WriteLine(i++);
Console.WriteLine(++i);
Console.WriteLine(i=20);
Console.WriteLine(i==20);
```

答案：
> 10
>
> 12
>
> 20
>
> True

解答：
> 前两个参考第80题，i++ 表达式的值为i自增之前的值，所以打印10，执行完成后i变成11，执行++i的时候表达式的值为自增以后的值12。C#中赋值表达式的值为变量被赋值的值，因此最后一个就输出i赋值后的值20

```csharp
while((line=reader.ReadLine())!=null)
{
}
```

下面程序的执行结果是什么？

```csharp
bool b=false;
if(b=true)
{
    Console.WriteLine("yes");
}
else
{
    Console.WriteLine("no");
}
```

## 77、如果不用VisualStudio，用哪个命令行编译C#程序？（*）（传智播客.Net培训班原创模拟题）

> 答：csc.exe。格式：csc.exe Test.cs
>
> csc(C Sharp compiler)

## 78、下列哪个名词和WebService不直接相关？（***B***）（传智播客.Net培训班原创模拟题）

> A、UDDI
>
> B、GUID
>
> C、WSDL
>
> D、SOAP

解释：
> UDDI用来自动发现WebService的协议（*）
>
> SOAP和HTTP的关系：SOAP基于Http协议的，和普通网页不同的是网页返回HTML，SOAP则是符合SOAP协议的XML数据。

## 79、.Net Framework中的类是专门供C#调用的是吗？（传智播客.Net培训班原创模拟题）

> 答：错。VB.Net等语言都可以调用.Net Framework中的类。CTS、CLS。

## 80、开放性问题：说出尽可能多的基于.Net Framework的语言。（*）（传智播客.Net培训班原创模拟题）

> 参考解答：C#、VB.Net、F#、PowerShell、IronPython、J#、Ruby.Net

## 81、.Net、ASP.Net、C#、VisualStudio之间的关系是什么？（传智播客.Net培训班原创模拟题）

> 答：.Net一般指的是.Net Framework，提供了基础的.Net类，这些类可以被任何一种.Net编程语言调用，.Net Framework还提供了CLR、JIT、GC等基础功能。
>
> ASP.Net是.Net中用来进行Web开发的一种技术，ASP.Net的页面部分写在aspx 文件中，逻辑代码通常通过Code-behind的方式用C#、VB.Net等支持.Net的语言编写。
>
> C#是使用最广泛的支持.Net的编程语言。除了C#还有VB.Net、IronPython等。
>
> VisualStudio是微软提供的用来进行.Net开发的集成开发环境（IDE），使用VisualStudio可以简化很多工作，不用程序员直接调用csc.exe等命令行进行程序的编译，而且VisualStudio提供了代码自动完成、代码高亮等功能方便开发。除了VisualStudio，还有SharpDevelop、MonoDevelop等免费、开源的IDE，VisualStudio Express版这个免费版本。

## 82、AJAX解决什么问题？如何使用AJAX？AJAX有什么问题需要注意？项目中哪里用到了AJAX？（传智播客.Net培训班原创模拟题）

> 答：AJAX解决的问题就是“无刷新更新页面”，用传统的HTML表单方式进行页面的更新时，每次都要将请求提交到服务器，服务器返回后再重绘界面，这样界面就会经历：提交→变白→重新显示这样一个过程，用户体验非常差，使用AJAX则不会导致页面重新提交、刷新。
>
> AJAX最本质的实现是 ***在Javascript中使用XMLHttpRequest进行Http的请求***，开发中通常使用UpdatePanel、JQuery等方式简化AJAX的开发，UpdatePanel的方式实现AJAX最简单，但是数据通讯量比较大，因为要来回传整个ViewState，而且不灵活，对于复杂的需求则可以使用JQuery提供的ajax功能。
>
> UpdatePanel的内部原理。
>
> AJAX最重要的问题是无法跨域请求(www.rupeng.com →so.rupeng.com)，也就是无法在页面中向和当前域名不同的页面发送请求，可以使用在当前页面所在的域的服务端做 ***代理页面*** 的方式解决。
>
> 在如鹏网项目中发帖的时候显示相关帖的功能、站内搜索项目中显示搜索Suggestion、数据采集项目中都用到了AJAX。

常考：
> ***不用任何框架编写一个AJAX程序。XHR:XmlHttpRequest***。

## 83、NET通过对各语言先编译成（ ***IL***），然后再执行时用（ ***JIT***）将其编译成本地平台代码，来实现异构平台下对象的互操作。（*）

## 84、Application 、Cookie和 Session 两种会话有什么不同？

> 答：Application是用来存取整个网站全局的信息，而Session是用来存取与具体某个访问者关联的信息。Cookie是保存在客户端的，机密信息不能保存在Cookie中，只能放小数据；Session是保存在服务器端的，比较安全，可以放大数据。

## 85、开放式问题：你经常访问的技术类的网站是什么？

> 博客园（www.cnblogs.com）、csdn、codeplex、codeproject、msdn文档、msdn论坛（遇到问题先到网上搜解决方案，还不行就问同事，同事也解决不了就去MSDN论坛提问，一定能得到解决）

## 86、你对.net的GC的理解

> GC是.Net的垃圾收集器，可以进行内存资源的回收，程序员无需关心资源的回收，当一个对象没有任何引用的时候就可以被回收了。一个对象可以被回收并不意味着一定会被立即回收，GC会选择时机进行回收。可以调用GC.Collect()让GC立即回收。GC不能回收非托管资源，对于非托管资源一般都实现了IDisposable接口，然后使用using关键字进行资源的回收。

## 87、请写一个SQL语句：从user表中取出name列中的起始字符是“北京”的全部记录

```sql
select * from [user] wherer name like '北京%'
```

## 88、请你简单的说明数据库建立索引的优缺点

> 使用索引可以加快数据的查询速度，不过由于数据插入过程中会建索引，所以会降低数据的插入、更新速度，索引还会占磁盘空间。

## 89、什么是WEB服务控件？使用WEB服务控件有那些优势、劣势？

> web服务控件就是可以在服务器执行的控件，优势在于可以回传数据（ViewState），带有事件驱动（doPostBack），简化了Html标签的使用，使得开发ASP.net程序可以像开发Winform程序一样简单。Web服务控件最终还是被渲染（Render）为Html标签。使用WEB服务控件的劣势是会生成一些无用的属性、ViewState等，不利于SEO，一般在内网系统或者互联网系统的后台中使用WEB服务控件。如果没有复杂的服务器交互动作，就不用Web服务器控件。
>
> runat=server的HTML控件有什么特点：路径不用程序员解析，可以使用“~”来虚拟路径。

## 90、下面程序的执行结果是什么？（传智播客.Net培训班原创模拟题）

```csharp
int i = 10;
if (i <=0) ;
    Console.WriteLine("i必须大于0");
Console.WriteLine("ok");
```

答案：
> i必须大于0
>
> ok

解答：
> 注意if (i <=0)后面的“;”，由于有了“;”，所以Console.WriteLine("i必须大于0")不再是和if一起的一部分，而是独立的语句。
>
> for循环也是如此。

## 92、开放式问题：工作中遇到不懂的问题是怎样去解决的？（传智播客.Net培训班原创模拟题）

> 参考解答：首先到百度上搜索中文的资料，一般都可以找到解决方案，如果还找不到解决方案就到google上搜索英文的资料，如果还没有解决方案就请教同事，如果同事也没有解决方案，就将问题提交到MSDN论坛。

## 93、开放性问题：能说出尽可能多的数据库管理系统？（传智播客.Net培训班原创模拟题）

> 参考解答：MSSQLServer、Oracle、Access、DB2、Sybase

## 94、开放性问题：你能说出尽可能多的你听说过的编程语言？（传智播客.Net培训班原创模拟题）（*）

> 参考解答：C#、VB.Net、Ada、Cobol、C、C++、Delphi、Erlang、F#、Fortran、Java、JavaScript、Pascal、Python、PowerShell、Ruby、Smalltalk。

## 95、请翻译下面的文章（*）

The BaseDataBoundControl is the root of all data-bound control classes. It defines the DataSource and DataSourceID properties and validates their assigned content. DataSource accepts enumerable objects obtained and assigned the ASP.NET 1.x way. 

Mycontrol1.DataSource = dataSet;

Mycontrol1.DataBind();

DataSourceID is a string and refers to the ID of a bound data source component. Once a control is bound to a data source, any further interaction between the two (in both reading and writing) is handled out of your control and hidden from view. This is both good and bad news at the same time. It is good (rather, great) news because you can eliminate a large quantity of code. The ASP.NET framework guarantees that correct code executes and is written according to recognized best practices. You're more productive because you author pages faster with the inherent certainty of having no subtle bugs in the middle. If you don't like this situation—look, the same situation that many ASP.NET 1.x developers complained about—you can stick to the old-style programming that passes through the DataSource property and DataBind method. Also in this case, the base class saves you from common practices even though the saving on the code is less remarkable.

参考翻译（自我感觉翻译的很烂，仅供参考。）：

> BaseDataBoundControl是所有的数据绑定控件类的根类。它定义了DataSource、DataSourceID两个属性，并且对为它们赋值的内容进行验证。DataSource属性接受读取、设置ASP.Net 1.x方式的IEnumerable 对象。
>
> Mycontrol1.DataSource = dataSet;
>
> Mycontrol1.DataBind();
>
> DataSourceID 是一个字符串，引用绑定的数据源控件的ID。一旦一个控件绑定到了数据源，这两者之间的任何交互（读和写）都会在你的控件之外被处理，并且被隐藏起来。这既是好消息也是坏消息。ASP.Net框架保证代码按照最佳实践进行代码的执行、编写。你会更加高效，因为你编写了更快的、没有任何错误的分页代码。如果你不喜欢这样的行为（看，就和ASP.Net 1.x开发人员抱怨的一样），你仍然可以使用老的编程风格，也就是将对象传递给DataSource属性，然后调用DataBind方法。另外在这种情况下，基类可以帮你避免常规的做法，即使看起来改进不明显。

## 96、在下述选项时,没有构成死循环的程序是 (***C***)

> A.int i=100;while (1) { i=i%100+1; if (i>100) break; }
>
> B.for (;;);
>
> C.int k=1000; do { ++k; }while(k>=10000);
>
> D.int s=36; while (s);--s;

## 97、下列哪个是和数据库访问技术关系不大的技术（***C***）

> A、SQLHelper
>
> B、EnterPrise Library
>
> C、AppDomain
>
> D、Linq

## 98、下列哪些说法是错误的（传智播客.Net培训班原创模拟题）

> A、将bmp格式的文件修改为jpg是修改图片格式最简单的方法
>
> B、将QQ动态表情显示在网页上用gif格式比较好
>
> C、将bmp格式的图片放到网页中可以优化网站速度
>
> D、png格式用在网页中可以实现透明的效果。

答案：A、C。
> A错误是因为修改文件的后缀并没有真的修改文件的格式，要使用Photoshop、mspaint等图片处理工具进行转换才可以。C错误是因为在网页中不能使用bmp图片。

## 99、从以下简写中任选一个简单描述

> OA\MIS\HRM\CRM\KM

参考答案：
> OA(Office Automation)：办公自动化
>
> MIS(Managment Information system)：管理信息系统
>
> HRM(Human Resource
>
> Managment)：人力资源管理，包括员工管理、薪资管理、入职管理、离职管理、报销管理、请假管理等
>
> CRM(Customer Relation Managment)：客户关系管理系统，包括客户管理、客户关怀、客户回访、投诉管理、咨询管理、报修管理等
>
> KM(Knowledge Managment)：知识管理
>
> ERP（Enterprise Resource Planning）：企业资源计划。

## 100、请在数据库中设计表来保存一个树状结构的公司组织结构

> 参考呼叫中心项目的代码和板书。

## 101、下面程序的执行结果是什么？

```csharp
    public struct Point
    {
        public int x;
        public int y;
        public Point(int x, int y)
        {
            this.x = x;
            this.y = y;
        }
    }
            Point p1 = new Point(100, 100);
            Point p2 = p1;
            p1.x = 200;
            Console.WriteLine("{0},{1}", p1.x, p2.x);
```

答案：
> 200,100

解答：结构体是复制传递的。

## 106、不用JQuery等框架实现AJAX无刷新登录。（常考）

> 提示：用纯XMLHttpRequest实现。

## 107、Http状态码各是什么意思。

> 301 ：永久重定向
>
> 302 ：重定向
>
> 404 ：页面不存在
>
> 500：服务器内部错误

## 108、 对html文本框进行赋值的JQuery语句，对html文本框进行取值的JQuery语句，对TextBox服务端控件进行取值的语句JQuery。

## 109、IE和FireFox的不同，IE6和IE8的不同。

> 1)XMLHttpRequest。不同浏览器实现AJAX的代码是不一样的。
>
> 2)CSS、Javascript、dom。有的浏览器不支持InnerText
>
> 3)我们项目开发中为了避免这些跨浏览器兼容的问题，就是用JQuery框架，他帮我们屏蔽了浏览器的差异。

## 110、Session有什么重大BUG，微软提出了什么方法加以解决？（常考）

> iis中由于有进程回收机制，系统繁忙的话Session会丢失，IIS重启也会造成Session丢失。这样用户就要重新登录或者重新添加购物车、验证码等放到Session中的信息。可以用State  server或SQL Server数据库的方式存储Session不过这种方式比较慢，而且无法捕获Session的END事件。但是（一定要写上，这样才够拽）我认为这不是Bug，只能说是In-Proc方式存储Session的缺陷，缺陷是和Bug不一样的，In-Proc方式存储Session会由服务器来决定什么时候释放Session，这是By Design，In-Proc方式不满足要求的话完全可以用StateServer和数据库的方式。
>
> StateServer还可以解决集群Session共享的问题。
>
> 配置StateServer的方法：

```url
http://support.microsoft.com/kb/317604
http://blog.csdn.net/zj1103/archive/2008/09/14/2926773.aspx
```

## 111、asp.net中<%%>、<%=%>、<%#%>的区别是什么

> <%%>是执行<%%>中的C#代码，<%=%>是将=后表达式的值输出到Response中，<%#%>是数据绑定，一般用在ListView、GridView、Repeater等控件的绑定中。数据绑定分为：Eval：单向绑定和Bind：双向绑定。

## 113、说说在软件设计中你遇到的以空间换时间的例子？

参考回答：
> 谈Cache(缓存)、索引这些例子。用额外的磁盘、内存空间的消耗来提高执行速度。

## 114、asp.net中的错误机制。（常考）

参考：
> 1）定制错误页来将显示一个友好的报错页面。
>
> 2）页面中未捕获一样会触发Ｐａｇｅ_Error，应用程序中的未捕获异常会触发Application_Error。通过HttpContext.Current.Server.GetLastError()拿到未捕捉异常，记录到Log4Net日志中。

## 115、不用中间变量交换两个变量

```csharp
int i = 500;
int j = int.MaxValue - 10;
//int i = 10;
//int j = 20;

Console.WriteLine("i={0},j={1}", i, j);

i = i + j;//i=30
j = i - j;//j=10;
i = i - j;//i=20;

Console.WriteLine("i={0},j={1}",i,j);
```

另外一个解决方案：位运算。

```csharp
int   a=5;
int   b=6;
a=a^b;
b=b^a;   //b^a相当于   b^a^b   也就是   b^a^b的值就是a了,   下边相同
a=a^b;
```

## 116、横表、纵表转换

### 1）

纵表结构 TableA
Name | Course | Grade
---|---|---
张三 | 语文 | 75
张三 | 数学 | 80
张三 | 英语 | 90
李四 | 语文 | 95
李四 | 数学 | 55
横表结构 TableB
Name | 语文 | 数学 | 英语
---|---|---|---
张三 | 75 | 80 | 90
李四 | 95 | 55 | 0
先理解：

```sql
select Name，
 (case Course when ‘语文‘ then Grade else 0 end) as 语文，
 (case Course when ‘数学‘ then Grade else 0 end) as 数学，
 (case Course when ‘英语‘ then Grade else 0 end) as 英语
from TableA
```

然后理解标准答案：

```sql
select Name，
sum(case Course when ‘语文‘ then Grade else 0 end) as 语文，
sum(case Course when ‘数学‘ then Grade else 0 end) as 数学，
sum(case Course when ‘英语‘ then Grade else 0 end) as 英语
from TableA
group by Name
```

### 2）、横表转纵表的"SQL"示例

横表结构: TEST_H2Z
ID | 姓名 | 语文 | 数学 | 英语
---|---|---|---|---
1 | 张三 | 80 | 90 | 70
2 | 李四 | 90 | 85 | 95
3 | 王五 | 88 | 75 | 90

转换后的表结构:
ID | 姓名 | 科目 | 成绩
---|---|---|---
1 | 张三 | 语文 | 80
2 | 张三 | 数学 | 90
3 | 张三 | 英语 | 70
4 | 李四 | 语文 | 90
5 | 李四 | 数学 | 80
6 | 李四 | 英语 | 99
7 | 王五 | 语文 | 85
8 | 王五 | 数学 | 96
9 | 王五 | 英语 | 88

横表转纵表SQL示例:

```sql
SELECT   姓名,'语文'   AS     科目,语文   AS   成绩   FROM   TEST_H2Z
UNION   ALL
SELECT   姓名,'数学'   AS     科目,数学   AS   成绩   FROM   TEST_H2Z
UNION   ALL
SELECT   姓名,'英语'   AS     科目,英语   AS   成绩   FROM   TEST_H2Z
ORDER BY 姓名,科目 DESC;
```

## 117、删除姓名、年龄重复的记录（常考）

Id | name | age | salary
---|---|---|---
1 | yzk | 80 | 1000
2 | yzk | 80 | 2000
3 | tom | 20 | 20000
4 | tom | 20 | 20000
5 | im | 20 | 20000

```sql
//取得不重复的数据
select * from Persons
where Id in
(
    SELECT     MAX(Id) AS Expr1
    FROM         Persons
    GROUP BY Name, Age
)
```

根据姓名、年龄分组，取出每组的Id最大值，然后将Id最大值之外的排除。

删除重复的数据：

```sql
delete from Persons
where Id not in
(
    SELECT     MAX(Id) AS Expr1
    FROM         Persons
    GROUP BY Name, Age
)
```

## 118、介绍几个使用过的开源的项目

> Lucene.net、NPOI、JQuery、ASP.Net AJAX  toolkit、Quartz.Net、JqueryUI、ASP.Net MVC。在CodePlex、SourceForge等网站上有更多的开源项目。

## 119、说出五个集合类

> List、Dictionary、Set、Stack（先入后出）、Queue、Tree等。

解答：HashSet用于盛放不同的数据，相同的数据只保留一份

## 120、有一个10个数的数组，计算其中不重复数字的个数。{3,5,9,8,10,5,3}

工程化的非最优解答：用HashSet

```csharp
int[] values = { 3, 5, 9, 8, 10, 5, 3 };
HashSet<int> set = new HashSet<int>();
foreach (int i in values)
{
    set.Add(i);
}

foreach (int i in set)
{
    Console.WriteLine(i);
}
```

## 121、现有1~100共一百个自然数，已随机放入一个有98个元素的数组a[98]。要求写出一个尽量简单的方案，找出没有被放入数组的那2个数，并在屏幕上打印这2个数。注意：程序不用实现自然数随机放入数组的过程。

参考：

```url
http://www.rupeng.com/forum/thread-1363-1-1.html
```

## 122、下面是一个由*号组成的4行倒三角形图案。要求：1、输入倒三角形的行数，行数的取值3-21之间，对于非法的行数，要求抛出提示“非法行数！”；2、在屏幕上打印这个指定了行数的倒三角形。

```list
    *******
     *****
      ***
       *
```

## 123、一个文本文件含有如下内容：

```list
4580616022644994|3000|赵涛
4580616022645017|6000|张屹
4580616022645090|3200|郑欣夏
```

上述文件每行为一个转账记录，第一列表示帐号，第二列表示金额，第三列表示开户人姓名。
创建一张数据库表（MS SQLServer数据库，表名和字段名自拟），请将上述文件逐条插入此表中。

## 124、一个文本文件含有如下内容，分别表示姓名和成绩：

```list
张三 90
李四 96
王五 78
赵六 82
```

提供用户一个控制台界面，允许用户输入要查询的姓名，输入姓名并且按回车以后，打印出此人的成绩，如果不输入姓名直接按回车则显示所有人的姓名以及成绩。（注意：不能使用数据库）

## 125、Equals和==的区别

参考：

```url
http://www.cnblogs.com/jiahaipeng/archive/2008/04/11/1146316.html

```

由重载-、+、>、<、隐式转换讲起

```csharp
////从Object继承的类，默认情况下==和Equals都比较引用。
////子类可以重载==运算符或者Equals方法改变他们的行为
////public static bool operator ==Person p1, Person p2)
```

下面程序结果是什么：

```csharp
string s1 = new string(new char[] { 't', 'e', 's', 't' });
string s2 = new string(new char[] { 't', 'e', 's', 't' });
object o1 = s1;
object o2 = s2;
Console.WriteLine(o1 == o2);
Console.WriteLine(o1.Equals(o2));
```

解答：
> 因为Equals是虚方法，而==是static方法（看到变量是什么类型就调用什么类型的方法）。

## 126、下面程序的执行结果是什么？

```csharp
class Program
{
    static void Main(string[] args)
    {
        Person p1 = new Person();//1:00
        Console.WriteLine(DateTime.Now);
        Thread.Sleep(1000 * 10);
        Console.WriteLine(DateTime.Now);
        Console.WriteLine(p1.BirthDay);
        //打印出来的是对象New出来的时间
        //因为字段是对象被new出来的时候初始化的

        Console.ReadKey();
    }
}

class Person
{
    public DateTime BirthDay = DateTime.Now;
}
```

再难一点

```csharp
class Person
{

    public static int A = 30;
    static Person()//静态构造函数在static字段初始化完成后执行
    {//静态构造函数只执行一次
        A++;
    }

    public int B = A++;//字段的初始化赋值代码只是在new一个对象的时候执行，而不是每次用字段的时候都执行
}
```

程序的执行结果是什么？

```csharp
Person p1 = new Person();
Console.WriteLine(p1.B);
Console.WriteLine(Person.A);
Console.WriteLine(p1.B);
Console.WriteLine(Person.A);

Person p2 = new Person();
Console.WriteLine(p2.B);
Console.WriteLine(Person.A);
```

## 127、说一下SQLServer中索引的两种类型（常考）

> 参考：聚簇(或者叫做聚集，cluster)索引和非聚簇索引。
>
> ***字典的拼音目录就是聚簇(cluster)索引，笔画目录就是非聚簇索引。这样查询“G到M的汉字”就非常快，而查询“6划到8划的字”则慢***。
>
> 聚簇索引是一种特殊索引，它使数据按照索引的排序顺序存放表中。聚簇索引类似于字典，即所有词条在字典中都以字母顺序排列。聚簇索引实际上重组了表中的数据，所以你只能 ***在表中建立一个*** 聚簇 ***索引***。
>
> 当数据按值的范围查询时，聚簇索引就显得特别有用。因为所有SQLServer都必需先找到所查询范围的第一行，然后依次下去，直到该范围的最后一个值找到为止，并且保证了所有其他值也落在这个范围内。举一个例子，一个应用程序要查找首字母位于G和P之间的姓名列表，SQLServer首先找到以字母G开头的名字，取出所有记录，直到找到以字母P开头的名字为止，这种方法使得查询过程非常高效。
>
> 进行大量数据改动的表不适宜用聚簇索引，因为SQLServer将不得不在表中维护行的次序。如果要索引的值极少，例如一个列包含的全都是1和0，创建聚簇索引就不是个好主意。如果表经常由一个指定的列来排序，该列将是簇索引的最佳候选列。这是因为表中的数据已经为你排好序了。如果访问一个表并使用BETWEEN、<、>、>=或<=操作符来返回一个范围的值时，应该考虑使用聚簇索引。

## 128、沪江网网申题：

### 1）.能否脱离VS用类似editplus的工具手写代码？你觉得如何才能提高代码的效率和性能？

> 可以，使用CSC.exe 来编译.cs文件！
>
> 可以根据业务流程、业务数据的特点进行优化，比如可以采用缓存、索引、表驱动等来提升代码的效率和性能，同时不要进行无意义的代码优化，重点优化系统的性能瓶颈。

### 2）.如何提高页面的显示速度？假如一个页面的加载时间是10.89s，你会用什么样的方式进行优化？

> 回答要大气！显得很牛！
>
> 提示：分而治之的思想。
>
> 首先要找出问题所在，是服务器端运行的速度慢还是服务器端到客户端的下载慢还是页面在浏览器的加载速度慢。
>
> 如果是服务器端运行速度慢，则找是数据库的原因还是算法的问题，如果是数据库的问题则尝试添加索引、优化SQL语句，如果是算法的问题，则优化算法。如果对于一些不经常改动的页面可以使用静态页技术！对于一些数据不需要及时更新的而且取数据的过程非常耗时可以使用缓存。页面中的内容可以按需加载（比如说可以像verycd网站的评论那样当用户需要看的时候再加载其内容），可以在图片需要显示的时候再进行加载。
>
> 如果是服务器端到客户端的下载慢则看是页面体积过于臃肿还是网络问题，如果是页面体积过于臃肿，则优化HTML代码，去掉无用的标签，压缩JS、CSS，可以用CSS Spirit技术将多个图片放到一个图片中，减少向服务器的请求。如果是网络问题，则尝试在不同的网络、地区部署服务器，然后使用CDN技术加速访问。
>
> 如果是页面中的JavaScript运行复杂导致运行速度慢，则优化JavaScript。
>
> webkaka：测网速。

### 3）.在程序编码的时候，你会对Sql注入漏洞的防范采取什么样的措施？

> 尽量不要拼SQL语句！使用参数化查询或存储过程可以防止SQL注入攻击！在必须用SQL拼接的地方对用户输入的内容进行检查、过滤。

### 4）.你会采用什么样的策略和方法来实现系统缓存？

> 在ASP.NET中 缓存有 页面缓存，数据源缓存，和一些自己定义的缓存！
>
> 对于那些整个页面不经常变化的我们可以使用页面缓存，而对于那些执行非常耗时的SQL语句并且数据的及时性要求不高的我们可以使用数据源缓存。
>
> 对于页面缓存、数据源缓存等都不满足要求的情况下采用直接操作HttpRuntime.Cache来自定义缓存策略。如果需要用多台Web服务器作为一个集群来承载网站的情况，则可以部署专门的分布式缓存服务器，比如Memcached。

### 5）网站想要实现文件防盗链的功能，说说你的解决方案。

> 读取HTTP报文头中的UrlReferrer在Application_BeginRequest中我们可以判断用户的请求是否来源于本网站。如果不是我们可以终止用户的请求（Response.End();）！

### 6）.有这样一个功能需求，用户新注册的时候需要给他推荐3个好友，说说你的推荐算法

> 比如说类似豆瓣网我们可以根据用户兴趣来匹配，类似于人人网那些地区性比较比较强的网站我们可以根据用户的地区来匹配。

### 7）.如果给学英语的用户设计一个在线应用，你会选择什么作为切入点，简述你的想法和理由。

> 英语学习资料的下载、在线答疑、用户交流作为切入点。

### 8）.你眼中的沪江是怎样的？谈谈你对沪江的理解

> 我眼中的沪江是为那些爱好外语，需要学习外语人提供一个学校交流的平台！

### 9）.是否有以下相关开发经验？如有请简要说明开发情况（有可看项目网址也请提供）。

> a、lucene相关开发经验
>
> b、分布式文件处理经验
>
> c、流媒体相关开发经验
>
> d、语音技术
>
> e、高负载网站开发
>
> f、手机相关开发

熟悉lucene，曾经用luncene.net做过一个DISCUZNT论坛的站内搜索。主要使用luncene.net、盘古分词、Log4Net、Quartz.net等组件。

### 129、请编程遍历WinForm页面上所有TextBox控件并给它赋值为string.Empty？

```csharp
foreach (System.Windows.Forms.Control control in this.Controls)
{
    if (control is System.Windows.Forms.TextBox)
    {
        System.Windows.Forms.TextBox tb = (System.Windows.Forms.TextBox)control ;
        tb.Text = String.Empty ;
    }
}
```

## 132、

```csharp
int i=2000;
object o=i;
i=2001;
int j=(int)o;
Console.WriteLine("i={0},o={1},j={2}",i,o,j);
```

输出的结果是：

## 134.一个数组：1,1,2,3,5,8,13,21...+m，求第30位数是多少？用递归实现；

写递归要确定两个：递归的终止条件；递归表达式。

解答：总结递归规律：F(n)=F(n-2)+F(n-1) Fibonacci数列

```csharp
static int F(int n)
{
    if (n == 1)
    {
        return 1;
    }
    if (n == 2)
    {
        return 1;
    }
    return F(n - 2) + F(n - 1);
}
```

非递归(有bug吗？)，递归算法的缺点：测试大数据

```csharp
int n = Convert.ToInt32(Console.ReadLine());
if(n<=0)
{Console.WRiteLine("必须大于0");return;}
if(n==1)  //时刻注意边界值！！！
{
    Console.WriteLine("1");
    return;
}
int[] data =new int[n];
data[0] = 1;
data[1] = 1;
for(int i=2;i<n;i++)
{
    data[i] = data[i-1]+data[i-2];
}
Console.WriteLine(data[n-1]);
```

上面程序的时间复杂度为O(n)，空间复杂度为O(n)

参考：
> 算法复杂度：***时间复杂度*** ：算法运行需要消耗的时间的 ***数量级***、***空间复杂度***：算法运行需要消耗的内存的数量级。
>
> 消耗的时间或者内存随着问题规模的扩大而成正比增加，就是O(n)。
>
> 消耗的时间或者内存随着问题规模的扩大而不变，就是O(1)。
>
> 消耗的时间或者内存随着问题规模的扩大而n*n增加，就是O(n*n)

算法复杂度只考虑 ***最差情况***（从一个数组中找出第一个大于10的数，时间复杂度为O(n)），并且算法复杂度 ***忽略常量和低阶***。把数组数一遍和数两遍的时间复杂度都是O(n)。把长度为n的数组数n/2遍的时间复杂度还是O(n*n)。
上课时把数组前后颠倒的算法的时间复杂度为O(n)，空间复杂度为O(1)。

### 补充：运算符重载，Equals、GetHashCode和==（*，几乎不会考）

1）>、<、+、-等运算符都可以重载，重载运算符后

重载比较运算符，重载>必须重载<

```csharp
class Person
{
    public string Name { get; set; }
    public int Age { get; set; }

    public static bool operator >(Person p1, Person p2)
    {
        return p1.Age > p2.Age;
    }

    public static bool operator <(Person p1, Person p2)
    {
        return p1.Age < p2.Age;
    }
}
```

2）重载加减号等

```csharp
public static int operator -(Person p1, Person p2)
{
    return p1.Age - p2.Age;
}
```

联想：两个datetime想减等于TimeSpan类型。

3）+重载

```csharp
public static Person operator +(Person p, int ageDelta)
{
    return new Person { Age = p.Age+ageDelta,Name=p.Name};
}
```

测试：Person p4 = p1 + 5;

4）隐式类型转换

```csharp
public static implicit operator Person(string s)
{
    return new Person() { Name = s };
}
```

这样string就可以隐式转换为Person

```csharp
public static implicit operator string(Person p1)
{
    return p1.Name;
}
```

这样Person就可以隐式转换为string

5）从Object类继承的==、Equals方法默认是比较引用。可以重载Equals或者==，可以行为不一样，但是建议实现一样。

```csharp
public static bool operator ==Person p1, Person p2)
{
    return p1.Age == p2.Age && p1.Name == p2.Name;
}

public static bool operator !=(Person p1, Person p2)
{
    return !(p1 == p2);
}

public override int GetHashCode()
{
    return (Name + Age).GetHashCode();
}

public override bool Equals(object obj)
{
    //标准写法
    if (obj == null)
    {
        return false;
    }
    Person p2 = (obj as Person);
    return this == p2;
}
```

## 135、Remoting与WebService的区别？

WebService中WSDL相当于对服务端方法的描述；.net Remoting中走的是二进制数据，因此必须一个描述服务端方法的接口类库。

1、新建接口项目，定义服务接口。
注意：remoting要添加对System.Runtime.Remoting的引用

2、新建服务器端项目（控制台的，或者WinForm，或者Windows服务等）
> 定义实现服务接口的类，还要继承继承自MarshalByRefObject类
>
> 服务器启动时调用

```csharp
//注册通道，通过TCP的9999端口对外提供服务
TcpChannel tcpChannel = new TcpChannel(9999);
ChannelServices.RegisterChannel(tcpChannel);

//注册服务：第一个参数为服务的实现类，第二个参数为父母的名字。
RemotingConfiguration.RegisterWellKnownServiceType(typeof(TestServiceImpl),
    "test", WellKnownObjectMode.Singleton);
```

> 注册服务。如果控制台程序，控制不要让程序退出，

```csharp
//主要目的是不要让服务器退出
while (true)
{
    string s = Console.ReadLine();
    if (s == "quit")
    {
        return;
    }
}
```

3、客户端：新建客户端项目，引用服务接口

```csharp
TcpChannel tcpChannel = new TcpChannel();
ChannelServices.RegisterChannel(tcpChannel, false);

ITestService test =
    (ITestService)Activator.GetObject(typeof(ITestService), "tcp://127.0.0.1:9999/test");//第一个参数为服务实现的接口，第二个参数为服务的地址：最后一部分是服务在服务器端RegisterWellKnownServiceType时第二个参数的名字
```

> 然后就可以调用服务端方法了。

- **WSDL**：WebService Definition Language。描述了WebService提供了哪些方法，方法的参数名字、类型等信息。
- **SOAP**：客户端向WebService服务器端发送请求时的数据格式，描述了：我要调用哪个方法，以及给方法传递的参数。服务器端想客户端返回的结果数据也是SOAP格式的。

> SOAP协议其实就是基于Http协议。

```chsharp
HttpContext.Current.Request.InputStream.Position = 0;
using (StreamReader sr = new StreamReader(HttpContext.Current.Request.InputStream))
{
    string body = sr.ReadToEnd();
}
```

```html
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body><Add xmlns="http://tempuri.org/"><i1>5</i1><i2>6</i2></Add></s:Body></s:Envelope>
```

> 因为Soap基于的Http就是开放协议，而Soap也是XML格式的，所以也很开放。

1、建立Web应用程序，添加一个“Web服务器”（asmx），asmx的需要外部访问的方法上标注 [WebMethod]

2、建立一个客户端程序，“添加服务引用”，地址填asmx的地址。然后“前往”。填合适的命名空间，然后【确定】。然后就可以使用那个命名空间下的**SoapClient类来调用服务端的方法。

    为什么不需要Remoting那样的中间接口项目了？因为有了WSDL，WSDL自我描述了服务有哪些方法和需要哪些参数。

- **WebService**应用场景：ERP取订单数据、炒股软件从证券公司服务器取数据、天气预报。
- **Net Remoing**效率高、适合于内网系统通讯、协议不开放、无法跨防火墙。
- **WebService**：协议开放，可以跨防火墙，效率低（Http协议，XML协议）、适合于两个系统之间的通讯。
- **WCF**：.统一Net Remoing和WebService等网络通讯协议的技术。用同一段代码可以底层跑不同的通讯协议。

## 136.ref与out的区别？

## 137.表A字段Id为numberic(18,0)，哪个SQL语句是错误的

```sql
select * from A where id='';
select * from A where id='13';
select * from A where id=null;
select * from A where id=' 13';
```

## 138.在SQLServer中求当前时间与2012-01-01 0：0:0相差的秒数？

## 139、你对Html 5了解多少？见课件“HTML演示”

> HTML5中提供了canvas画布、video标签等。

## 140、做一个表格，三行三列，第一列，前两行合一；第二行，后两列合一。

## 141、下面的HTML代码

```html
<style type="text/css">
        #Text1{ background-color:Red}
        .txt{ background-color:Green}
        input {background-color:Black}
    </style>
<input id="Text1" type="text" class="txt" />
<input type="text" class="txt" />
```

两个文本框各是什么颜色？

> 参考资料：个人大于集体：元素单独设置的样式>class命名样式>标签样式。样式override父级别的。

## 142、北京时代引擎

### 1）UML主要有哪些组成部分，试将其图形绘出？

> UML早已淘汰，IBM捞钱的老东西！敏捷开发、迭代式开发（持续集成）、结对编程。Rational

### 2 ）  Web2.0有哪些主要应用？

> 不是由网站产生的，而是由用户产生网站内容（UGC：User Generate Content），比如微博、博客、开心网、猫扑、糗事百科、博客园等都是。

### 3 ） 主要AJAx框架有哪些？

> UpdatePanel、Ajax Toolkit。JQuery AJAx、最根本的就是XHR。

### 4 ） AJAx与后台交换数据主要有哪些方式

### 5）   Web页面的布局安排主要有哪两种方式。参考：Div和Table

### 6 ）  什么是测试驱动的开发，在.NET平台上如何实现。使用VS2010的测试项目，**使用Assert类进行断言。单元测试。输入输入验证是否是期望的输出**。

- **TDD（Test Driven Develop）**：测试驱动开发。通过编写测试案例（TestCase），使用单元测试（UnitTest）工具进行测试，每次对系统修改，都运行一次单元测试，把所有可能的条件都自动测试一遍，这样保证代码没有明显的Bug。
- **编写测试用例（TestCase）**：什么样的期望输入、什么样的期望输出。编写测试用例的时候主要考虑临界情况。
- **NUnit**：开源的单元测试工具。JUnit（Java版本）、CPPUnit（C++版本）、DUnit（Delphi）、PyUnit（Python）、JSUnit（JavaScript）。统称：XUnit。

### 7）  从Web界面上获得一个对象的50个属性值，如何更好的验证并保存到数据库？

### 8 ） 什么是ASP.NET MVC框架，有什么特点和优势？

## 143. 请编程实现一个冒泡排序算法？（背下来）

```csharp
int[] array = new int[] { 3, 9, 2, 90, 22, 105, 99 };

for (int i = 0; i < array.Length - 1; i++)
{
    for (int j = i + 1; j < array.Length; j++)
    {
        if (array[j] < array[i])
        {
            int temp = 0;
            temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
}

foreach (int i in array)
{
    Console.WriteLine(i);
}
```

## 144. 求以下表达式的值，写出您想到的一种或几种实现方法：1-2+3-4+……+m

> 用数学的方法。

## 145、传智播客.net培训精品就业班学员总结SQL题

表一：student_info
学号 | 姓名 | 性别 | 出生年月 | 家庭住址 | 备注
---|---|---|---|---|---
0001 | 张三 | 男 | 1981-8-9 | 北京 | NULL

表二：curriculum
课程编号 | 课程名称 | 学分
---|---|---
0001 | 计算机基础 | 2
0002 | C语言 | 2

表三：grade
学号 | 课程编号 | 分数
---|---|---
0001 | 0001 | 80
0001 | 0002 | 90

题目：

### 条件查询：

1.在GRADE表中查找80-90份的学生学号和分数

```sql
select 学号,分数 from grade where 分数 between 80 and 90
```

2.在GRADE 表中查找课程编号为003学生的平均分

```sql
select avg(分数) from grade where 课程编号='003'
```

3.在GRADE 表中查询学习各门课程的人数

```sql
select课程编号,count(学号) as 人数from grade group by 课程编号
```

4.查询所有姓张的学生的学号和姓名

```sql
select  姓名,学号 from student_info where 姓名 like '张%'
```

### 嵌套查询：

1、查询和学号’0001’的这位同学性别相同的所有同学的姓名和出生年月

```sql
SELECT 姓名, 出生年月
  FROM student_info
 WHERE 性别 IN (SELECT 性别
                    FROM student_info
                   WHERE sno = '0001')
```

2、查询所有选修课程编号为0002 和0003的学生的学号、姓名和性别

```sql
SELECT 学号, 姓名, 性别
  FROM student_info
 WHERE 学号 IN (SELECT 学号
                    FROM grade
                   WHERE     课程编号 = '0002'
                         AND 学号 IN (SELECT 学号
                                          FROM grade
                                         WHERE 课程编号 = '0001'))
```

3、查询出学号为0001的学生的分数比0002号学生最低分高的课程编号的课程编号和分数

```sql
SELECT 课程编号, 分数
  FROM grade
 WHERE     学号 = '0001'
       AND 分数 > (SELECT min (分数)
                       FROM grade
                      WHERE 学号 = '0002')
```

### 多表查询：

1、查询分数在80-90分的学生的学号、姓名、分数

```sql
SELECT student_info.学号, student_info.姓名, grade.分数
  FROM student_info, grade
 WHERE grade.分数 BETWEEN 80 AND 90
```

2、查询学习了’C语言’课程的学生学号、姓名和分数

```sql
SELECT student_info.学号,
       student_info.姓名,
       grade.成绩from student_info,
       grade,
       curriculum
 WHERE     student_info.学号 = grade.学号
       AND grade.课程号 = curriculum.课程号
       AND curriculum.课程名 = 'C语言'
```

3、查询所有学生的总成绩，要求列出学号、姓名、总成绩，没有选课的学生总成绩为空。

```sql
SELECT grade.学号, student_info.姓名, sum (grade.成绩) AS 总成绩
  FROM student_info, grade
 WHERE grade.学号 = student_info.学号
GROUP BY grade.学号, student_info.姓名
```

题目、活期存款中，“储户”通过“存取款单”和“储蓄所”发生联系。假定储户包括：账号，姓名，电话，地址，存款额；“储蓄所”包括：储蓄所编号，名称，电话，地址（假定一个储户可以在不同得储蓄所存取款）

- 1、写出设计以上表格的语句（4分）
- 2、创建一个触发器TR1完成下面内容：

    当向“存取款单”表中插入数据时，如果存取标志＝１则应该更改储户表让存款额加上存取金额，如果存取标志＝0则应该更改储户表让存款额减去存取金额,如果余额不足显示余额不足错误。

```sql
CREATE TABLE CREATE TRIGGER tr1 on qukuan after insert
AS
BEGIN

declare @sid nvarchar(50)
declare @type int
declare @qian int
declare @yuer int
select @sid=sid,@type=[type],@m=m from inserted
select @yuer=yuer from cunkuan
if(@type=1)
    begin
    update cunkuan set yuer=yuer+@qian
    end
else
    begin
    if(@yuer<@qian)
        begin
            print '余额不足'
        end
    else
        begin
        update cunkuan set yuer=yuer-@qian
        end
    end

END
GO
```

> 本题用到下面三个关系表：

- CARD     借书卡:   (CNO 卡号，NAME  姓名，CLASS 班级)
- BOOKS    图书:     (BNO 书号，BNAME 书名,AUTHOR 作者，PRICE 单价，QUANTITY 库存册数 )
- BORROW   借书记录: (CNO 借书卡号，BNO 书号，RDATE 还书日期

> 备注：限定每人每种书只能借一本；库存册数随借书、还书而改变。
>
> 要求实现如下处理：
1.写出自定义函数，要求输入借书卡号能得到该卡号所借书金额的总和

```csharp
CREATE FUNCTION getSUM (@CNO INT)
   RETURNS INT
AS
   BEGIN
      DECLARE @sum   INT
      SELECT @sum = sum (price)
      FROM BOOKS
      WHERE bno IN (SELECT bno
                      FROM BORROW
                     WHERE cno = @CNO)

      RETURN @sum
   END
GO
```

2． 找出借书超过5本的读者,输出借书卡号及所借图书册数。

```sql
SELECT CNO, count (BNO) AS 借书数量
  FROM BORROW
GROUP BY CNO
HAVING count (BNO) > 3
```

3． 查询借阅了"水浒"一书的读者，输出姓名及班级。

```sql
SELECT name, class
  FROM card
 WHERE cno IN (SELECT cno
                 FROM borrow
                WHERE bno IN (SELECT bno
                                FROM BOOKS
                               WHERE bname = '水浒'))
```

4． 查询过期未还图书，输出借阅者（卡号）、书号及还书日期。

```sql
select CNO,BNO,RDATE from borrow where getdate()>RDATE
```

5． 查询书名包括"网络"关键词的图书，输出书号、书名、作者。

```sql
select bno,bname,author from books where bname like '网络%'
```

6． 查询现有图书中价格最高的图书，输出书名及作者。

```sql
SELECT bname, author
  FROM books
 WHERE price IN (SELECT max (price) FROM books)
```

7． 查询当前借了"计算方法"但没有借"计算方法习题集"的读者，输出其借书卡号，并按卡号降序排序输出。

```sql
SELECT cno
  FROM borrow
 WHERE     bno IN (SELECT bno
                     FROM books
                    WHERE bname = '计算方法')
       AND cno NOT IN
              (SELECT cno
                 FROM borrow
                WHERE bno IN (SELECT bno
                                FROM books
                               WHERE bname = '计算方法习题集'))
ORDER BY cno DESC
```

或

```sql
SELECT a.CNO
  FROM BORROW a, BOOKS b
 WHERE     a.BNO = b.BNO
       AND b.BNAME = N'计算方法'
       AND NOT EXISTS
                  (SELECT *
                     FROM BORROW aa, BOOKS bb
                    WHERE     aa.BNO = bb.BNO
                          AND bb.BNAME = N'计算方法习题集'
                          AND aa.CNO = a.CNO)
ORDER BY a.CNO DESC
```

8． 将"C01"班同学所借图书的还期都延长一周。

```sql
UPDATE borrow
   SET rdate = dateadd (day, 7, rdate)
  FROM BORROW
 WHERE cno IN (SELECT cno
                 FROM card
                WHERE class = '一班')
```

9． 从BOOKS表中删除当前无人借阅的图书记录。

```sql
DELETE A
  FROM BOOKS a
 WHERE NOT EXISTS
          (SELECT *
             FROM BORROW
            WHERE BNO = a.BNO)
```

10．如果经常按书名查询图书信息，请建立合适的索引。
> (这个不确定对不 90%应该是对的 自己看了下书写的)

```sql
CREATE CLUSTERED INDEX IDX_BOOKS_BNAME ON BOOKS(BNAME)
```

11．在BORROW表上建立一个触发器，完成如下功能：如果读者借阅的书名是"数据库技术及应用"，就将该读者的借阅记录保存在BORROW_SAVE表中（注ORROW_SAVE表结构同BORROW表）。

```sql
CREATE TRIGGER TR_SAVE
   ON BORROW
   FOR INSERT, UPDATE
AS
IF @@ROWCOUNT > 0
   INSERT BORROW_SAVE
      SELECT i.*
        FROM INSERTED i, BOOKS b
       WHERE i.BNO = b.BNO AND b.BNAME = N'数据库技术及应用'
```

12．建立一个视图，显示"力01"班学生的借书信息（只要求显示姓名和书名）。

```sql
CREATE VIEW V_VIEW
AS
   SELECT name, bname
     FROM books, card, borrow
    WHERE     borrow.cno = card.cno
          AND borrow.bno = books.bno
          AND class = '一班'
```

13．查询当前同时借有"计算方法"和"组合数学"两本书的读者，输出其借书卡号，并按卡号升序排序输出。

```sql
SELECT a.cno
  FROM borrow a, borrow b
 WHERE     a.cno = b.cno
       AND a.bno IN (SELECT bno
                       FROM books
                      WHERE bname = '计算方法')
       AND b.bno IN (SELECT bno
                       FROM books
                      WHERE bname = '组合数学')
ORDER BY a.cno DESC
```

或

```sql
SELECT a.CNO
  FROM BORROW a, BOOKS b
 WHERE a.BNO = b.BNO AND b.BNAME IN ('计算方法', '组合数学')
GROUP BY a.CNO
HAVING COUNT (*) = 2
ORDER BY a.CNO DESC
```

14、用事务实现如下功能：一个借书卡号借走某书号的书，则该书的库存量减少1，当某书的库存量不够1本的时候，该卡号不能借该书

```sql
ALTER PROCEDURE pro_jieshu
   @cno INT, @bno INT, @date DATETIME
AS
   BEGIN
      BEGIN TRAN

      DECLARE @quantity   INT

      SELECT @quantity = quantity
      FROM books
      WHERE bno = @bno

      INSERT INTO borrow
      VALUES (@cno, @bno, @date)

      UPDATE books
         SET quantity = @quantity - 1
       WHERE bno = @bno

      IF (@quantity > 0)
         BEGIN
            COMMIT TRAN
         END
      ELSE
         BEGIN
            PRINT '已无库存'
            ROLLBACK
         END
   END
GO
```

15、用游标实现将书号为‘A001’的书本的价格提高10元

```sql
DECLARE @bno   INT
DECLARE @bname   NVARCHAR (50)
DECLARE @author   NVARCHAR (50)
DECLARE @price   INT
DECLARE @quantity   INT

DECLARE
   mycursor CURSOR FOR
      SELECT * FROM books

OPEN mycursor

FETCH NEXT FROM mycursor
  INTO @bno, @bname, @author, @price, @quantity

WHILE (@@fetch_status = 0)
BEGIN
   IF (@bno = 2)
      BEGIN
         UPDATE books
            SET price = @price + 10
          WHERE CURRENT OF mycursor
      END

   FETCH NEXT FROM mycursor
     INTO @bno, @bname, @author, @price, @quantity
END

CLOSE mycursor

DEALLOCATE mycursor
```

---
    Student(S#,Sname,Sage,Ssex) 学生表
    Course(C#,Cname,T#) 课程表
    SC(S#,C#,score) 成绩表
    Teacher(T#,Tname) 教师表

问题：

1、查询“001”课程比“002”课程成绩高的所有学生的学号；

```sql
SELECT a.S#
  FROM (SELECT s#, score
          FROM SC
         WHERE C# = '001') a,
       (SELECT s#, score
          FROM SC
         WHERE C# = '002') b
 WHERE a.score > b.score AND a.s# = b.s#;
```

2、查询平均成绩大于60分的同学的学号和平均成绩；

```sql
SELECT S#, avg (score)
  FROM sc
GROUP BY S#
HAVING avg (score) > 60;
```

3、查询所有同学的学号、姓名、选课数、总成绩；

```sql
SELECT Student.S#,
       Student.Sname,
       count (SC.C#),
       sum (score)
  FROM Student LEFT OUTER JOIN SC ON Student.S# = SC.S#
GROUP BY Student.S#, Sname
```

4、查询姓“李”的老师的个数；

```sql
SELECT count (DISTINCT (Tname))
  FROM Teacher
 WHERE Tname LIKE '李%';
```

5、查询没学过“叶平”老师课的同学的学号、姓名；

```sql
SELECT Student.S#, Student.Sname
  FROM Student
 WHERE S# NOT IN
          (SELECT DISTINCT (SC.S#)
             FROM SC, Course, Teacher
            WHERE     SC.C# = Course.C#
                  AND Teacher.T# = Course.T#
                  AND Teacher.Tname = '叶平');
```

6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；

```sql
SELECT Student.S#, Student.Sname
  FROM Student, SC
 WHERE     Student.S# = SC.S#
       AND SC.C# = '001'
       AND EXISTS
              (SELECT *
                 FROM SC AS SC_2
                WHERE SC_2.S# = SC.S# AND SC_2.C# = '002');
```

7、查询学过“叶平”老师所教的所有课的同学的学号、姓名；

```sql
SELECT S#, Sname
  FROM Student
 WHERE S# IN
          (SELECT S#
             FROM SC, Course, Teacher
            WHERE     SC.C# = Course.C#
                  AND Teacher.T# = Course.T#
                  AND Teacher.Tname = '叶平'
           GROUP BY S#
           HAVING count (SC.C#) =
                     (SELECT count (C#)
                        FROM Course, Teacher
                       WHERE Teacher.T# = Course.T# AND Tname = '叶平'));
```

8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；

```sql
SELECT S#, Sname
  FROM (SELECT Student.S#,
               Student.Sname,
               score,
               (SELECT score
                  FROM SC SC_2
                 WHERE SC_2.S# = Student.S# AND SC_2.C# = '002')
                  score2
          FROM Student, SC
         WHERE Student.S# = SC.S# AND C# = '001') S_2
 WHERE score2 < score;
```

9、查询所有课程成绩小于60分的同学的学号、姓名；

```sql
SELECT S#, Sname
  FROM Student
 WHERE S# NOT IN (SELECT Student.S#
                    FROM Student, SC
                   WHERE S.S# = SC.S# AND score > 60);
```

10、查询没有学全所有课的同学的学号、姓名；

```sql
SELECT Student.S#, Student.Sname
  FROM Student, SC
 WHERE Student.S# = SC.S#
GROUP BY Student.S#, Student.Sname
HAVING count (C#) < (SELECT count (C#) FROM Course);
```

11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名；

```sql
SELECT S#, Sname
  FROM Student, SC
 WHERE     Student.S# = SC.S#
       AND C# IN (SELECT C#
                    FROM SC
                   WHERE S# = '1001');
```

12、查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名；

```sql
SELECT DISTINCT SC.S#, Sname
  FROM Student, SC
 WHERE     Student.S# = SC.S#
       AND C# IN (SELECT C#
                    FROM SC
                   WHERE S# = '001');
```

13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩；

```sql
UPDATE SC
   SET score =
          (SELECT avg (SC_2.score)
             FROM SC SC_2
            WHERE SC_2.C# = SC.C#)
  FROM Course, Teacher
 WHERE     Course.C# = SC.C#
       AND Course.T# = Teacher.T#
       AND Teacher.Tname = '叶平'
```

14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名；

```sql
SELECT S#
  FROM SC
 WHERE C# IN (SELECT C#
                FROM SC
               WHERE S# = '1002')
GROUP BY S#
HAVING count (*) = (SELECT count (*)
                      FROM SC
                     WHERE S# = '1002');
```

15、删除学习“叶平”老师课的SC表记录；

```sql
DELETE SC
  FROM course, Teacher
 WHERE Course.C# = SC.C# AND Course.T# = Teacher.T# AND Tname = '叶平';
```

16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、2、号课的平均成绩；

```sql
INSERT SC
   SELECT S#,
          '002',
          (SELECT avg (score)
             FROM SC
            WHERE C# = '002')
     FROM Student
    WHERE S# NOT IN (SELECT S#
                       FROM SC
                      WHERE C# = '002');
```

17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示： 学生ID,,数据库,企业管理,英语,有效课程数,有效平均分

```sql
SELECT S# AS 学生ID,
       (SELECT score
          FROM SC
         WHERE SC.S# = t.S# AND C# = '004')
          AS 数据库,
       (SELECT score
          FROM SC
         WHERE SC.S# = t.S# AND C# = '001')
          AS 企业管理,
       (SELECT score
          FROM SC
         WHERE SC.S# = t.S# AND C# = '006')
          AS 英语,
       COUNT (*) AS 有效课程数,
       AVG (t.score) AS 平均成绩
  FROM SC AS t
GROUP BY S#
ORDER BY avg (t.score)
```

18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分

```sql
SELECT L.C# AS 课程ID, L.score AS 最高分, R.score AS 最低分
  FROM SC L, SC AS R
 WHERE     L.C# = R.C#
       AND L.score = (SELECT MAX (IL.score)
                        FROM SC AS IL, Student AS IM
                       WHERE L.C# = IL.C# AND IM.S# = IL.S#
                      GROUP BY IL.C#)
       AND R.Score = (SELECT MIN (IR.score)
                        FROM SC AS IR
                       WHERE R.C# = IR.C#
                      GROUP BY IR.C#);
```

19、按各科平均成绩从低到高和及格率的百分数从高到低顺序

```sql
SELECT t.C# AS 课程号,
       max (course.Cname) AS 课程名,
       isnull (AVG (score), 0) AS 平均成绩,
         100
       * SUM (CASE WHEN isnull (score, 0) >= 60 THEN 1 ELSE 0 END)
       / COUNT (*)
          AS 及格百分数
  FROM SC T, Course
 WHERE t.C# = course.C#
GROUP BY t.C#
ORDER BY   100
         * SUM (CASE WHEN isnull (score, 0) >= 60 THEN 1 ELSE 0 END)
         / COUNT (*) DESC
```

20、查询如下课程平均成绩和及格率的百分数(用"1行"显示): 企业管理（001），马克思（002），OO&UML （003），数据库（004）

```sql
SELECT   SUM (CASE WHEN C# = '001' THEN score ELSE 0 END)
       / SUM (CASE C# WHEN '001' THEN 1 ELSE 0 END)
          AS 企业管理平均分,
         100
       * SUM (CASE WHEN C# = '001' AND score >= 60 THEN 1 ELSE 0 END)
       / SUM (CASE WHEN C# = '001' THEN 1 ELSE 0 END)
          AS 企业管理及格百分数,
         SUM (CASE WHEN C# = '002' THEN score ELSE 0 END)
       / SUM (CASE C# WHEN '002' THEN 1 ELSE 0 END)
          AS 马克思平均分,
         100
       * SUM (CASE WHEN C# = '002' AND score >= 60 THEN 1 ELSE 0 END)
       / SUM (CASE WHEN C# = '002' THEN 1 ELSE 0 END)
          AS 马克思及格百分数,
         SUM (CASE WHEN C# = '003' THEN score ELSE 0 END)
       / SUM (CASE C# WHEN '003' THEN 1 ELSE 0 END)
          AS UML平均分,
         100
       * SUM (CASE WHEN C# = '003' AND score >= 60 THEN 1 ELSE 0 END)
       / SUM (CASE WHEN C# = '003' THEN 1 ELSE 0 END)
          AS UML及格百分数,
         SUM (CASE WHEN C# = '004' THEN score ELSE 0 END)
       / SUM (CASE C# WHEN '004' THEN 1 ELSE 0 END)
          AS 数据库平均分,
         100
       * SUM (CASE WHEN C# = '004' AND score >= 60 THEN 1 ELSE 0 END)
       / SUM (CASE WHEN C# = '004' THEN 1 ELSE 0 END)
          AS 数据库及格百分数
  FROM SC
```

21、查询不同老师所教不同课程平均分从高到低显示

```sql
SELECT max (Z.T#) AS 教师ID,
       MAX (Z.Tname) AS 教师姓名,
       C.C# AS 课程ＩＤ,
       MAX (C.Cname) AS 课程名称,
       AVG (Score) AS 平均成绩
  FROM SC AS T, Course AS C, Teacher AS Z
 WHERE T.C# = C.C# AND C.T# = Z.T#
GROUP BY C.C#
ORDER BY AVG (Score) DESC
```

22、查询如下课程成绩第 3 名到第 6 名的学生成绩单：企业管理（001），马克思（002），UML （003），数据库（004）
> [学生ID],[学生姓名],企业管理,马克思,UML,数据库,平均成绩

```sql
SELECT DISTINCT TOP 3
       SC.S# AS 学生学号,
       Student.Sname AS 学生姓名,
       T1.score AS 企业管理,
       T2.score AS 马克思,
       T3.score AS UML,
       T4.score AS 数据库,
         ISNULL (T1.score, 0)
       + ISNULL (T2.score, 0)
       + ISNULL (T3.score, 0)
       + ISNULL (T4.score, 0)
          AS 总分
  FROM Student,
       SC LEFT JOIN SC AS T1 ON SC.S# = T1.S# AND T1.C# = '001' LEFT JOIN SC AS T2 ON     SC.S# =
                                                                                             T2.S#
                                                                                      AND T2.C# =
                                                                                             '002' LEFT JOIN SC AS T3 ON     SC.S# =
                                                                                                                                T3.S#
                                                                                                                         AND T3.C# =
                                                                                                                                '003' LEFT JOIN SC AS T4 ON     SC.S# =
                                                                                                                                                                   T4.S#
                                                                                                                                                            AND T4.C# =
                                                                                                                                                                   '004'
 WHERE     student.S# = SC.S#
       AND   ISNULL (T1.score, 0)
           + ISNULL (T2.score, 0)
           + ISNULL (T3.score, 0)
           + ISNULL (T4.score, 0) NOT IN
              (SELECT DISTINCT TOP 15 WITH TIES
                        ISNULL (T1.score, 0)
                      + ISNULL (T2.score, 0)
                      + ISNULL (T3.score, 0)
                      + ISNULL (T4.score, 0)
                 FROM sc
                      LEFT JOIN sc AS T1 ON sc.S# = T1.S# AND T1.C# = 'k1'
                      LEFT JOIN sc AS T2 ON sc.S# = T2.S# AND T2.C# = 'k2'
                      LEFT JOIN sc AS T3 ON sc.S# = T3.S# AND T3.C# = 'k3'
                      LEFT JOIN sc AS T4 ON sc.S# = T4.S# AND T4.C# = 'k4'
               ORDER BY   ISNULL (T1.score, 0)
                        + ISNULL (T2.score, 0)
                        + ISNULL (T3.score, 0)
                        + ISNULL (T4.score, 0) DESC);
```

23、统计列印各科成绩,各分数段人数:课程ID,课程名称,[100-85],[85-70],[70-60],[ <60]

```sql
SELECT SC.C# AS 课程ID,
       Cname AS 课程名称,
       SUM (CASE WHEN score BETWEEN 85 AND 100 THEN 1 ELSE 0 END)
          AS [100 - 85],
       SUM (CASE WHEN score BETWEEN 70 AND 85 THEN 1 ELSE 0 END) AS [85 - 70],
       SUM (CASE WHEN score BETWEEN 60 AND 70 THEN 1 ELSE 0 END) AS [70 - 60],
       SUM (CASE WHEN score < 60 THEN 1 ELSE 0 END) AS [60 -]
  FROM SC, Course
 WHERE SC.C# = Course.C#
GROUP BY SC.C#, Cname;
```

24、查询学生平均成绩及其名次

```sql
SELECT   1
       + (SELECT COUNT (DISTINCT 平均成绩)
            FROM (SELECT S#, AVG (score) AS 平均成绩
                    FROM SC
                  GROUP BY S#) AS T1
           WHERE 平均成绩 > T2.平均成绩)
          AS 名次,
       S# AS 学生学号,
       平均成绩
  FROM (SELECT S#, AVG (score) 平均成绩
          FROM SC
        GROUP BY S#) AS T2
ORDER BY 平均成绩 DESC;
```

25、查询各科成绩前三名的记录:(不考虑成绩并列情况)

```sql
SELECT t1.S# AS 学生ID, t1.C# AS 课程ID, Score AS 分数
  FROM SC t1
 WHERE score IN (SELECT TOP 3 score
                   FROM SC
                  WHERE t1.C# = C#
                 ORDER BY score DESC)
ORDER BY t1.C#;
```

26、查询每门课程被选修的学生数

```sql
SELECT c#, count (S#) FROM sc GROUP BY C#;
```

27、查询出只选修了一门课程的全部学生的学号和姓名

```sql
SELECT SC.S#, Student.Sname, count (C#) AS 选课数
  FROM SC, Student
 WHERE SC.S# = Student.S#
GROUP BY SC.S#, Student.Sname
HAVING count (C#) = 1;
```

28、查询男生、女生人数

```sql
SELECT count (Ssex) AS 男生人数
  FROM Student
GROUP BY Ssex
HAVING Ssex = '男';

SELECT count (Ssex) AS 女生人数
  FROM Student
GROUP BY Ssex
HAVING Ssex = '女';
```

29、查询姓“张”的学生名单

```sql
    SELECT Sname FROM Student WHERE Sname like '张%';
```

30、查询同名同性学生名单，并统计同名人数

```sql
SELECT Sname, count (*)
  FROM Student
GROUP BY Sname
HAVING count (*) > 1;;
```

31、1981年出生的学生名单(注：Student表中Sage列的类型是datetime)

```sql
SELECT Sname, CONVERT (CHAR (11), DATEPART (year, Sage)) AS age
  FROM student
 WHERE CONVERT (CHAR (11), DATEPART (year, Sage)) = '1981';
```

32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列

```sql
SELECT C#, Avg (score)
  FROM SC
GROUP BY C#
ORDER BY Avg (score), C# DESC;
```

33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩

```sql
SELECT Sname, SC.S#, avg (score)
  FROM Student, SC
 WHERE Student.S# = SC.S#
GROUP BY SC.S#, Sname
HAVING avg (score) > 85;
```

34、查询课程名称为“数据库”，且分数低于60的学生姓名和分数

```sql
SELECT Sname, isnull (score, 0)
  FROM Student, SC, Course
 WHERE     SC.S# = Student.S#
       AND SC.C# = Course.C#
       AND Course.Cname = '数据库'
       AND score < 60;
```

35、查询所有学生的选课情况；

```sql
SELECT SC.S#,
       SC.C#,
       Sname,
       Cname
  FROM SC, Student, Course
 WHERE SC.S# = Student.S# AND SC.C# = Course.C#;
```

36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；

```sql
SELECT DISTINCT student.S#,
                student.Sname,
                SC.C#,
                SC.score
  FROM student, Sc
 WHERE SC.score >= 70 AND SC.S# = student.S#;
```

37、查询不及格的课程，并按课程号从大到小排列

```sql
SELECT c# FROM sc WHERE score < 60 ORDER BY C#;
```

38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名；

```sql
SELECT SC.S#, Student.Sname
  FROM SC, Student
 WHERE SC.S# = Student.S# AND Score > 80 AND C# = '003';
```

39、求选了课程的学生人数

```sql
SELECT count (*) FROM sc;
```

40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩

```sql
SELECT Student.Sname, score
  FROM Student,
       SC,
       Course C,
       Teacher
 WHERE     Student.S# = SC.S#
       AND SC.C# = C.C#
       AND C.T# = Teacher.T#
       AND Teacher.Tname = '叶平'
       AND SC.score = (SELECT max (score)
                         FROM SC
                        WHERE C# = C.C#);
```

41、查询各个课程及相应的选修人数

```sql
    select count(*) from sc group by C#;
```

42、查询不同课程成绩相同的学生的学号、课程号、学生成绩

```sql
SELECT DISTINCT A.S#, B.score
  FROM SC A, SC B
 WHERE A.Score = B.Score AND A.C# <> B.C#;
```

43、查询每门功成绩最好的前两名

```sql
SELECT t1.S# AS 学生ID, t1.C# AS 课程ID, Score AS 分数
  FROM SC t1
 WHERE score IN (SELECT TOP 2 score
                   FROM SC
                  WHERE t1.C# = C#
                 ORDER BY score DESC)
ORDER BY t1.C#;
```

44、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列

```sql
SELECT C# AS 课程号, count (*) AS 人数
  FROM sc
GROUP BY C#
ORDER BY count (*) DESC, c#
```

45、检索至少选修两门课程的学生学号

```sql
SELECT S#
  FROM sc
GROUP BY s#
HAVING count (*) >= 2
```

46、查询全部学生都选修的课程的课程号和课程名

```sql
SELECT C#, Cname
  FROM Course
 WHERE C# IN (SELECT c#
                FROM sc
              GROUP BY c#)
```

47、查询没学过“叶平”老师讲授的任一门课程的学生姓名

```sql
SELECT Sname
  FROM Student
 WHERE S# NOT IN
          (SELECT S#
             FROM Course, Teacher, SC
            WHERE     Course.T# = Teacher.T#
                  AND SC.C# = course.C#
                  AND Tname = '叶平');
```

48、查询两门以上不及格课程的同学的学号及其平均成绩

```sql
SELECT S#, avg (isnull (score, 0))
  FROM SC
 WHERE S# IN (SELECT S#
                FROM SC
               WHERE score < 60
              GROUP BY S#
              HAVING count (*) > 2)
GROUP BY S#;
```

49、检索“004”课程分数小于60，按分数降序排列的同学学号

```sql
SELECT S#
  FROM SC
 WHERE C# = '004' AND score < 60
ORDER BY score DESC;
```

50、删除“002”同学的“001”课程的成绩

```sql
DELETE FROM Sc WHERE S# = '001' AND C# = '001';
```

14、假定在建BOOKS表时没有定义主码，写出为BOOKS表追加定义主码的语句

```sql
ALTER TABLE BOOKS ADD PRIMARY KEY(BNO)
```

15.1、 将NAME最大列宽增加到10个字符（假定原为6个字符）

```sql
ALTER TABLE CARD ALTER COLUMN NAME varchar(10)
```

15.2、 为该表增加1列NAME（系名），可变长，最大20个字符

```sql
ALTER TABLE CARD ADD 系名 varchar(20)
```

## 树的广度优先遍历

```csharp
private void PrintNodeWidthFirst(IEnumerable<TreeNode> treenodes)
{
    //要遍历的下级节点
    List<TreeNode> listNodes = new List<TreeNode>();
    foreach (TreeNode childNode in treenodes)
    {
        //如果节点有子节点则将子节点加入listNodes以备稍后遍历
        if (childNode.Nodes.Count > 0)
        {
            listNodes.AddRange(childNode.Nodes.OfType<TreeNode>());
        }
        textBox1.AppendText(childNode.Text + "\r\n");
    }
    //如果有待遍历的子节点
    if (listNodes.Count > 0)
    {
        PrintNodeWidthFirst(listNodes);
    }
}
```

锁的问题：

```csharp
public void Test(int i)
{
    lock (this)
    {
        if (i > 10)
        {
            i--;
            Test(i);
        }
    }
}
```

执行Test(10)是否会造成死锁？

> 答：不会，因为多线程才有锁的问题，线程无法自己锁自己（单线程必然是有先后执行顺序的，没必要锁）
